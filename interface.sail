$include <concurrency_interface.sail>

/*
   - mem_acc : Type, An architecture specific description of the access kind.
     This may also contain arbitrary architecture specific metadata about the
     access.
*/
enum AccessType = {
  AccessType_IFETCH, // instruction fetch
  AccessType_RW // read or write
}
struct AccessDescriptor = {
  acctype : AccessType,
  atomicop : bool,
  standalone: bool,
  read : bool,
  write : bool,
}
function base_AccessDescriptor (acctype : AccessType) -> AccessDescriptor = struct {
  acctype = acctype,
  atomicop = false,
  standalone = true,
  read = false,
  write = false,
}
function create_iFetchAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_IFETCH);
  accdesc.read = true;
  accdesc
}
function create_readAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_RW);
  accdesc.read = true;
  accdesc
}
function create_writeAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_RW);
  accdesc.write = true;
  accdesc
}

// Memory access generated by an explicit instruction
function mem_acc_is_explicit     (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW

// Memory access requested by an instruction fetch
function mem_acc_is_ifetch       (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_IFETCH

// Memory access is a translation table walk. False as memory model is flat.
function mem_acc_is_ttw          (acc : AccessDescriptor) -> bool = false

// Access is relaxed 
function mem_acc_is_relaxed      (acc : AccessDescriptor) -> bool = true

// Access uses release-acquire semantics
function mem_acc_is_rel_acq_rcpc (acc : AccessDescriptor) -> bool = false
function mem_acc_is_rel_acq_rcsc (acc : AccessDescriptor) -> bool = false

// access is from a standalone instruction (not part of an atomic sequence of instructionns)
function mem_acc_is_standalone   (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & acc.standalone

// access is part of an exclusive instruction 
function mem_acc_is_exclusive    (acc : AccessDescriptor) -> bool = false

// access is for part of an atomic read-modify-write instruction
function mem_acc_is_atomic_rmw   (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & acc.atomicop

/* instantiate */
instantiation sail_mem_read with
  'addr_size = 64,
  'addr_space = unit,
  'mem_acc = AccessDescriptor,
  'abort = unit,
  'CHERI = false,
  'cap_size_log = 0,
  mem_acc_is_explicit = mem_acc_is_explicit,
  mem_acc_is_ifetch = mem_acc_is_ifetch,
  mem_acc_is_ttw = mem_acc_is_ttw,
  mem_acc_is_relaxed = mem_acc_is_relaxed,
  mem_acc_is_rel_acq_rcpc = mem_acc_is_rel_acq_rcpc,
  mem_acc_is_rel_acq_rcsc = mem_acc_is_rel_acq_rcsc,
  mem_acc_is_standalone = mem_acc_is_standalone,
  mem_acc_is_exclusive = mem_acc_is_exclusive,
  mem_acc_is_atomic_rmw = mem_acc_is_atomic_rmw

instantiation sail_mem_write with
  'addr_size = 64,
  'addr_space = unit,
  'mem_acc = AccessDescriptor,
  'abort = unit,
  'CHERI = false,
  'cap_size_log = 0,
  mem_acc_is_explicit = mem_acc_is_explicit,
  mem_acc_is_ifetch = mem_acc_is_ifetch,
  mem_acc_is_ttw = mem_acc_is_ttw,
  mem_acc_is_relaxed = mem_acc_is_relaxed,
  mem_acc_is_rel_acq_rcpc = mem_acc_is_rel_acq_rcpc,
  mem_acc_is_rel_acq_rcsc = mem_acc_is_rel_acq_rcsc,
  mem_acc_is_standalone = mem_acc_is_standalone,
  mem_acc_is_exclusive = mem_acc_is_exclusive,
  mem_acc_is_atomic_rmw = mem_acc_is_atomic_rmw

/* memory read and write */
val read_memory : forall 'N, 'N > 0.
  (int('N), bits(64), AccessDescriptor) -> bits(8 * 'N)

function read_memory(N, addr, accdesc) = {
  let req : Mem_request('N, 0, 64, unit, AccessDescriptor) = struct {
    access_kind   = accdesc,
    address       = truncate(addr, 64),
    address_space = (),
    size          = N,
    num_tag       = 0
  };

  match sail_mem_read(req) {
    Ok((bytes, _)) => from_bytes_le(bytes),
    Err(_e) => { exit() }
  }
}

val write_memory : forall 'N, 'N > 0. (int('N), bits(64), bits(8 * 'N), AccessDescriptor) -> unit
function write_memory(N, addr, value, accdesc) = {
  let req : Mem_request('N, 0, 64, unit, AccessDescriptor) = struct {
    access_kind = accdesc,
    address = truncate(addr, 64),
    address_space = (),
    size = N,
    num_tag = 0,
  };
  match sail_mem_write(req,to_bytes_le(N, value),[]) {
    Ok(_) => (),
    Err(_) => exit(),
  }
}