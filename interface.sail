$include <concurrency_interface.sail>
$include <concurrency_interface/tlbi.sail>
$include <concurrency_interface/exception.sail>
$include <concurrency_interface/cache_op.sail>
$include <concurrency_interface/translation.sail>

/* 
   This interface depends on a few parameters:
   - CHERI : Bool, Whether CHERI is active on this architecture, which means the
     memory has capability tags
   - cap_size_log : Int, If CHERI is on, the log2 of the size of capabilities in
     bytes. For example for 16 bytes capabilities, this should be 4.
*/

// addr_size : Int, The size of addresses to be used, in bits
type addr_size : Int = 64
let addr_size' : int(64) = 64

/*
addr_space : Type, An extra tag on the address to identify its address
     space. For Arm this is Secure/Non-Secure, for all other architecture this
     should probably be unit.
*/
type addr_space : Type = unit
let addr_space_def = ()

/*
abort : Type, The type of memory aborts/access failure: To be
     returned when the access has failed. In system-level instantiations, this is
     expected to be for physical memory abort (e.g. SError in Arm)
*/
enum Fault = {
  // see 6.5.1 Call and Return Operation for Interrupt or Exception Handling Procedures (Intel manual)
  Fault_DB, // Debug
  Fault_NMI, // Non-maskable interrupt
  Fault_DF, // Double Fault
  Fault_NP, // Segment Not Present
  Fault_SS, // Stack Segment Fault
  Fault_GP, // General Protection
  Fault_PF, // Page Fault
  Fault_AC, // Alignment Check
  Fault_MC, // Machine Check
  Fault_CP, // Control Protection Exception
}
type abort: Type = Fault

/*
   - mem_acc : Type, An architecture specific description of the access kind.
     This may also contain arbitrary architecture specific metadata about the
     access.
*/
enum AccessType = {
  AccessType_IFETCH, // instruction fetch
  AccessType_RW // read or write
}
struct AccessDescriptor = {
  acctype : AccessType,
  cpl: bits(2), //  current privilege level
  acqsc : bool,
  acqpc : bool,
  relsc : bool,
  exclusive : bool,
  atomicop : bool,
  read : bool,
  write : bool,
}
function base_AccessDescriptor (acctype : AccessType) -> AccessDescriptor = struct {
  acctype = acctype,
  cpl = 0b11, // lowest privilege level
  acqsc = true, // acquire (load / read) sequential consistency applied
  acqpc = false, // acquire with processor consistency (weaker than sequential consistency)
  relsc = true, // release (store / write) sequential consistency applied
  exclusive = false,
  atomicop = false,
  read = false,
  write = false,
}
function create_iFetchAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_IFETCH);
  accdesc.read = true;
  accdesc.write = false;
  accdesc.cpl = CS[CPL];
  accdesc
}
function create_readAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_RW);
  accdesc.read = true;
  accdesc.write = false;
  accdesc.cpl = CS[CPL];
  accdesc
}
function create_writeAccessDescriptor() -> AccessDescriptor = {
  var accdesc = base_AccessDescriptor(AccessType_RW);
  accdesc.write = true;
  accdesc.read = false;
  accdesc.cpl = CS[CPL];
  accdesc
}

// Memory access generated by an explicit instruction
function mem_acc_is_explicit     (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW

// Memory access requested by an instruction fetch
function mem_acc_is_ifetch       (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_IFETCH

// Memory access is a translation table walk. False as memory model is flat.
function mem_acc_is_ttw          (acc : AccessDescriptor) -> bool = false

// Access is relaxed (can be reordered by hardware). False as we are implementing a model with sequential consistency.
function mem_acc_is_relaxed      (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & not_bool(acc.acqpc) & not_bool(acc.acqsc) & not_bool(acc.relsc)

// Access is release acquire rcpc = release consistent processor consistent
function mem_acc_is_rel_acq_rcpc (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & acc.acqpc

// Access is release acquire rcsc = release consistent sequentially consistent
function mem_acc_is_rel_acq_rcsc (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & (acc.acqsc | acc.relsc)

// access is from a standalone instruction (not part of an atomic sequence of instructionns)
function mem_acc_is_standalone   (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & not_bool(acc.exclusive) & not_bool(acc.atomicop)

// access is part of an exclusive instruction 
function mem_acc_is_exclusive    (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & acc.exclusive

// access is for part of an atomic read-modify-write instruction
function mem_acc_is_atomic_rmw   (acc : AccessDescriptor) -> bool = acc.acctype == AccessType_RW & acc.atomicop

/* instantiate */
instantiation sail_mem_read with
  'addr_size = addr_size,
  'addr_space = addr_space,
  'mem_acc = AccessDescriptor,
  'abort = abort,
  'CHERI = false,
  'cap_size_log = 0,
  mem_acc_is_explicit = mem_acc_is_explicit,
  mem_acc_is_ifetch = mem_acc_is_ifetch,
  mem_acc_is_ttw = mem_acc_is_ttw,
  mem_acc_is_relaxed = mem_acc_is_relaxed,
  mem_acc_is_rel_acq_rcpc = mem_acc_is_rel_acq_rcpc,
  mem_acc_is_rel_acq_rcsc = mem_acc_is_rel_acq_rcsc,
  mem_acc_is_standalone = mem_acc_is_standalone,
  mem_acc_is_exclusive = mem_acc_is_exclusive,
  mem_acc_is_atomic_rmw = mem_acc_is_atomic_rmw

instantiation sail_mem_write with
  'addr_size = addr_size,
  'addr_space = addr_space,
  'mem_acc = AccessDescriptor,
  'abort = abort,
  'CHERI = false,
  'cap_size_log = 0,
  mem_acc_is_explicit = mem_acc_is_explicit,
  mem_acc_is_ifetch = mem_acc_is_ifetch,
  mem_acc_is_ttw = mem_acc_is_ttw,
  mem_acc_is_relaxed = mem_acc_is_relaxed,
  mem_acc_is_rel_acq_rcpc = mem_acc_is_rel_acq_rcpc,
  mem_acc_is_rel_acq_rcsc = mem_acc_is_rel_acq_rcsc,
  mem_acc_is_standalone = mem_acc_is_standalone,
  mem_acc_is_exclusive = mem_acc_is_exclusive,
  mem_acc_is_atomic_rmw = mem_acc_is_atomic_rmw

instantiation sail_mem_address_announce with
  'addr_size = addr_size,
  'addr_space = addr_space,
  'mem_acc = AccessDescriptor,
  'abort = abort,
  'CHERI = false,
  'cap_size_log = 0