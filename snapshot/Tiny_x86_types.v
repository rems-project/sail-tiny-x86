(*Generated by Sail from Tiny_x86.*)


From stdpp Require Import base countable pretty.
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Definition reg_index : Type := Z.

Inductive reg :=
| REG_HIGH_BYTE : Z -> reg
| REG_NORMAL : reg_index -> reg.
Arguments reg : clear implicits.

Definition sail_reg_encode (x : reg) := match x with
  | REG_HIGH_BYTE x' => encode (0, encode x')
  | REG_NORMAL x' => encode (1, encode x') end.
Definition sail_reg_decode x : option reg := match decode x with
  | Some (0, x') => REG_HIGH_BYTE <$> decode x'
  | Some (1, x') => REG_NORMAL <$> decode x'
  | _ => None end.
Lemma sail_reg_decode_encode : forall (x : reg), sail_reg_decode (sail_reg_encode x)  = Some x.
Proof.
  unfold sail_reg_decode, sail_reg_encode;
  intros [x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_reg : EqDecision reg := decode_encode_eq_dec sail_reg_encode sail_reg_decode
  sail_reg_decode_encode .

#[export]
Instance Countable_reg : Countable reg := {|
  encode := sail_reg_encode;
  decode := sail_reg_decode;
  decode_encode := sail_reg_decode_encode
|}.
#[export]
Instance dummy_reg : Inhabited (reg) := { inhabitant := REG_HIGH_BYTE inhabitant }.

Definition rflags : Type := mword 64.

Inductive AccessType := AccessType_IFETCH | AccessType_RW.
Definition num_of_AccessType (arg_ : AccessType) : Z :=
   match arg_ with | AccessType_IFETCH => 0 | AccessType_RW => 1 end.

Definition AccessType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : AccessType :=
   let l__0 := arg_ in
   if Z.eqb (l__0) (0) then AccessType_IFETCH
   else AccessType_RW.

Lemma AccessType_num_of_roundtrip (x : AccessType) : AccessType_of_num (num_of_AccessType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_AccessType_injective (x y : AccessType) : num_of_AccessType x = num_of_AccessType y -> x = y.
  intro.
  rewrite <- (AccessType_num_of_roundtrip x).
  rewrite <- (AccessType_num_of_roundtrip y).
  congruence.
Qed.
Definition AccessType_eq_dec (x y : AccessType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_AccessType x) (num_of_AccessType y) with
  | left e => left (num_of_AccessType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition AccessType_beq (x y : AccessType) : bool :=
  Z.eqb (num_of_AccessType x) (num_of_AccessType y).
Lemma AccessType_beq_iff x y : AccessType_beq x y = true <-> x = y.
  unfold AccessType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_AccessType_injective | congruence].
Qed.
Lemma AccessType_beq_refl x : AccessType_beq x x = true.
apply AccessType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_AccessType : EqDecision AccessType := AccessType_eq_dec.
#[export]
Instance Countable_AccessType : Countable AccessType.
refine {|
  encode x := encode (num_of_AccessType x);
  decode x := z ← decode x; mret (AccessType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite AccessType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_AccessType : Inhabited AccessType := { inhabitant := AccessType_IFETCH }.


Record AccessDescriptor := {
  AccessDescriptor_acctype : AccessType;
  AccessDescriptor_atomicop : bool;
  AccessDescriptor_read : bool;
  AccessDescriptor_write : bool;
}.
Arguments AccessDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AccessDescriptor : EqDecision AccessDescriptor.
   intros [x0 x1 x2 x3].
   intros [y0 y1 y2 y3].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AccessDescriptor : Countable AccessDescriptor.
refine {|
  encode x := encode (AccessDescriptor_acctype x, AccessDescriptor_atomicop x, AccessDescriptor_read x, AccessDescriptor_write x);
  decode x := '(x0, x1, x2, x3) ← decode x;
              mret (Build_AccessDescriptor x0 x1 x2 x3)
|}.
abstract (
  intros [x0 x1 x2 x3];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AccessDescriptor : Settable _ := settable! Build_AccessDescriptor <AccessDescriptor_acctype; AccessDescriptor_atomicop; AccessDescriptor_read; AccessDescriptor_write>.
#[export]
Instance dummy_AccessDescriptor : Inhabited (AccessDescriptor) := {
  inhabitant := {|
    AccessDescriptor_acctype := inhabitant;
    AccessDescriptor_atomicop := inhabitant;
    AccessDescriptor_read := inhabitant;
    AccessDescriptor_write := inhabitant
|} }.


Inductive Barrier := Barrier_SFENCE | Barrier_LFENCE | Barrier_MFENCE.
Definition num_of_Barrier (arg_ : Barrier) : Z :=
   match arg_ with | Barrier_SFENCE => 0 | Barrier_LFENCE => 1 | Barrier_MFENCE => 2 end.

Definition Barrier_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : Barrier :=
   let l__0 := arg_ in
   if Z.eqb (l__0) (0) then Barrier_SFENCE
   else if Z.eqb (l__0) (1) then Barrier_LFENCE
   else Barrier_MFENCE.

Lemma Barrier_num_of_roundtrip (x : Barrier) : Barrier_of_num (num_of_Barrier x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Barrier_injective (x y : Barrier) : num_of_Barrier x = num_of_Barrier y -> x = y.
  intro.
  rewrite <- (Barrier_num_of_roundtrip x).
  rewrite <- (Barrier_num_of_roundtrip y).
  congruence.
Qed.
Definition Barrier_eq_dec (x y : Barrier) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Barrier x) (num_of_Barrier y) with
  | left e => left (num_of_Barrier_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Barrier_beq (x y : Barrier) : bool :=
  Z.eqb (num_of_Barrier x) (num_of_Barrier y).
Lemma Barrier_beq_iff x y : Barrier_beq x y = true <-> x = y.
  unfold Barrier_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Barrier_injective | congruence].
Qed.
Lemma Barrier_beq_refl x : Barrier_beq x x = true.
apply Barrier_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Barrier : EqDecision Barrier := Barrier_eq_dec.
#[export]
Instance Countable_Barrier : Countable Barrier.
refine {|
  encode x := encode (num_of_Barrier x);
  decode x := z ← decode x; mret (Barrier_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Barrier_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Barrier : Inhabited Barrier := { inhabitant := Barrier_SFENCE }.


Definition mem_addr : Type := bits 64.

Definition imm8 : Type := bits 8.

Definition imm16 : Type := bits 16.

Definition imm32 : Type := bits 32.

Definition imm64 : Type := bits 64.

Inductive imm :=
| IMM8 : imm8 -> imm
| IMM16 : imm16 -> imm
| IMM32 : imm32 -> imm
| IMM64 : imm64 -> imm.
Arguments imm : clear implicits.

Definition sail_imm_encode (x : imm) := match x with
  | IMM8 x' => encode (0, encode x')
  | IMM16 x' => encode (1, encode x')
  | IMM32 x' => encode (2, encode x')
  | IMM64 x' => encode (3, encode x') end.
Definition sail_imm_decode x : option imm := match decode x with
  | Some (0, x') => IMM8 <$> decode x'
  | Some (1, x') => IMM16 <$> decode x'
  | Some (2, x') => IMM32 <$> decode x'
  | Some (3, x') => IMM64 <$> decode x'
  | _ => None end.
Lemma sail_imm_decode_encode : forall (x : imm), sail_imm_decode (sail_imm_encode x)  = Some x.
Proof.
  unfold sail_imm_decode, sail_imm_encode;
  intros [x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_imm : EqDecision imm := decode_encode_eq_dec sail_imm_encode sail_imm_decode
  sail_imm_decode_encode .

#[export]
Instance Countable_imm : Countable imm := {|
  encode := sail_imm_encode;
  decode := sail_imm_decode;
  decode_encode := sail_imm_decode_encode
|}.
#[export]
Instance dummy_imm : Inhabited (imm) := { inhabitant := IMM8 inhabitant }.

Inductive rm_operand :=
| rm_REG : reg -> rm_operand
| rm_MEM : mem_addr -> rm_operand.
Arguments rm_operand : clear implicits.

Definition sail_rm_operand_encode (x : rm_operand) := match x with
  | rm_REG x' => encode (0, encode x')
  | rm_MEM x' => encode (1, encode x') end.
Definition sail_rm_operand_decode x : option rm_operand := match decode x with
  | Some (0, x') => rm_REG <$> decode x'
  | Some (1, x') => rm_MEM <$> decode x'
  | _ => None end.
Lemma sail_rm_operand_decode_encode : forall (x : rm_operand), sail_rm_operand_decode
  (sail_rm_operand_encode x)  = Some x.
Proof.
  unfold sail_rm_operand_decode, sail_rm_operand_encode;
  intros [x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_rm_operand : EqDecision rm_operand := decode_encode_eq_dec
  sail_rm_operand_encode sail_rm_operand_decode sail_rm_operand_decode_encode .

#[export]
Instance Countable_rm_operand : Countable rm_operand := {|
  encode := sail_rm_operand_encode;
  decode := sail_rm_operand_decode;
  decode_encode := sail_rm_operand_decode_encode
|}.
#[export]
Instance dummy_rm_operand : Inhabited (rm_operand) := { inhabitant := rm_REG inhabitant }.

Inductive rmi_operand :=
| rmi_IMM : imm -> rmi_operand
| rmi_REG : reg -> rmi_operand
| rmi_MEM : mem_addr -> rmi_operand.
Arguments rmi_operand : clear implicits.

Definition sail_rmi_operand_encode (x : rmi_operand) := match x with
  | rmi_IMM x' => encode (0, encode x')
  | rmi_REG x' => encode (1, encode x')
  | rmi_MEM x' => encode (2, encode x') end.
Definition sail_rmi_operand_decode x : option rmi_operand := match decode x with
  | Some (0, x') => rmi_IMM <$> decode x'
  | Some (1, x') => rmi_REG <$> decode x'
  | Some (2, x') => rmi_MEM <$> decode x'
  | _ => None end.
Lemma sail_rmi_operand_decode_encode : forall (x : rmi_operand), sail_rmi_operand_decode
  (sail_rmi_operand_encode x)  = Some x.
Proof.
  unfold sail_rmi_operand_decode, sail_rmi_operand_encode;
  intros [x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_rmi_operand : EqDecision rmi_operand := decode_encode_eq_dec
  sail_rmi_operand_encode sail_rmi_operand_decode sail_rmi_operand_decode_encode .

#[export]
Instance Countable_rmi_operand : Countable rmi_operand := {|
  encode := sail_rmi_operand_encode;
  decode := sail_rmi_operand_decode;
  decode_encode := sail_rmi_operand_decode_encode
|}.
#[export]
Instance dummy_rmi_operand : Inhabited (rmi_operand) := { inhabitant := rmi_IMM inhabitant }.

Definition operand_size : Type := Z.

Inductive ast :=
| MOV : (operand_size * rm_operand * rmi_operand) -> ast
| XOR : (bool * operand_size * rm_operand * rmi_operand) -> ast
| SFENCE : unit -> ast
| LFENCE : unit -> ast
| MFENCE : unit -> ast
| CMP : (operand_size * rm_operand * rmi_operand) -> ast
| PUSH : (operand_size * rmi_operand) -> ast
| POP : (operand_size * rm_operand) -> ast
| ADD : (bool * operand_size * rm_operand * rmi_operand) -> ast
| SUB : (bool * operand_size * rm_operand * rmi_operand) -> ast
| IMUL : (operand_size * reg_index * rm_operand) -> ast
| CALL : imm32 -> ast
| LEAVE : Z -> ast
| RET : unit -> ast
| JMP : imm8 -> ast
| JNS : imm8 -> ast
| JNE : imm8 -> ast.
Arguments ast : clear implicits.

Definition sail_ast_encode (x : ast) := match x with
  | MOV x' => encode (0, encode x')
  | XOR x' => encode (1, encode x')
  | SFENCE x' => encode (2, encode x')
  | LFENCE x' => encode (3, encode x')
  | MFENCE x' => encode (4, encode x')
  | CMP x' => encode (5, encode x')
  | PUSH x' => encode (6, encode x')
  | POP x' => encode (7, encode x')
  | ADD x' => encode (8, encode x')
  | SUB x' => encode (9, encode x')
  | IMUL x' => encode (10, encode x')
  | CALL x' => encode (11, encode x')
  | LEAVE x' => encode (12, encode x')
  | RET x' => encode (13, encode x')
  | JMP x' => encode (14, encode x')
  | JNS x' => encode (15, encode x')
  | JNE x' => encode (16, encode x') end.
Definition sail_ast_decode x : option ast := match decode x with
  | Some (0, x') => MOV <$> decode x'
  | Some (1, x') => XOR <$> decode x'
  | Some (2, x') => SFENCE <$> decode x'
  | Some (3, x') => LFENCE <$> decode x'
  | Some (4, x') => MFENCE <$> decode x'
  | Some (5, x') => CMP <$> decode x'
  | Some (6, x') => PUSH <$> decode x'
  | Some (7, x') => POP <$> decode x'
  | Some (8, x') => ADD <$> decode x'
  | Some (9, x') => SUB <$> decode x'
  | Some (10, x') => IMUL <$> decode x'
  | Some (11, x') => CALL <$> decode x'
  | Some (12, x') => LEAVE <$> decode x'
  | Some (13, x') => RET <$> decode x'
  | Some (14, x') => JMP <$> decode x'
  | Some (15, x') => JNS <$> decode x'
  | Some (16, x') => JNE <$> decode x'
  | _ => None end.
Lemma sail_ast_decode_encode : forall (x : ast), sail_ast_decode (sail_ast_encode x)  = Some x.
Proof.
  unfold sail_ast_decode, sail_ast_encode;
  intros [x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_ast : EqDecision ast := decode_encode_eq_dec sail_ast_encode sail_ast_decode
  sail_ast_decode_encode .

#[export]
Instance Countable_ast : Countable ast := {|
  encode := sail_ast_encode;
  decode := sail_ast_decode;
  decode_encode := sail_ast_decode_encode
|}.
#[export]
Instance dummy_ast : Inhabited (ast) := { inhabitant := MOV inhabitant }.

Definition REX_typ : Type := mword 8.

Definition modRMByte : Type := mword 8.

Definition SIBByte : Type := mword 8.

Record decodedPrefixes := {
  decodedPrefixes_lock : bool;
  decodedPrefixes_op_size_override : bool;
  decodedPrefixes_mandatory_prefix_66H : bool;
  decodedPrefixes_REX : REX_typ;
}.
Arguments decodedPrefixes : clear implicits.
#[export]
Instance Decidable_eq_decodedPrefixes : EqDecision decodedPrefixes.
   intros [x0 x1 x2 x3].
   intros [y0 y1 y2 y3].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_decodedPrefixes : Countable decodedPrefixes.
refine {|
  encode x := encode (decodedPrefixes_lock x, decodedPrefixes_op_size_override x, decodedPrefixes_mandatory_prefix_66H x, decodedPrefixes_REX x);
  decode x := '(x0, x1, x2, x3) ← decode x;
              mret (Build_decodedPrefixes x0 x1 x2 x3)
|}.
abstract (
  intros [x0 x1 x2 x3];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_decodedPrefixes : Settable _ := settable! Build_decodedPrefixes <decodedPrefixes_lock; decodedPrefixes_op_size_override; decodedPrefixes_mandatory_prefix_66H; decodedPrefixes_REX>.
#[export]
Instance dummy_decodedPrefixes : Inhabited (decodedPrefixes) := {
  inhabitant := {|
    decodedPrefixes_lock := inhabitant;
    decodedPrefixes_op_size_override := inhabitant;
    decodedPrefixes_mandatory_prefix_66H := inhabitant;
    decodedPrefixes_REX := inhabitant
|} }.


Inductive addressingMethod := addressingMethod_E | addressingMethod_G.
Definition num_of_addressingMethod (arg_ : addressingMethod) : Z :=
   match arg_ with | addressingMethod_E => 0 | addressingMethod_G => 1 end.

Definition addressingMethod_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : addressingMethod :=
   let l__0 := arg_ in
   if Z.eqb (l__0) (0) then addressingMethod_E
   else addressingMethod_G.

Lemma addressingMethod_num_of_roundtrip (x : addressingMethod) : addressingMethod_of_num (num_of_addressingMethod x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_addressingMethod_injective (x y : addressingMethod) : num_of_addressingMethod x = num_of_addressingMethod y -> x = y.
  intro.
  rewrite <- (addressingMethod_num_of_roundtrip x).
  rewrite <- (addressingMethod_num_of_roundtrip y).
  congruence.
Qed.
Definition addressingMethod_eq_dec (x y : addressingMethod) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_addressingMethod x) (num_of_addressingMethod y) with
  | left e => left (num_of_addressingMethod_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition addressingMethod_beq (x y : addressingMethod) : bool :=
  Z.eqb (num_of_addressingMethod x) (num_of_addressingMethod y).
Lemma addressingMethod_beq_iff x y : addressingMethod_beq x y = true <-> x = y.
  unfold addressingMethod_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_addressingMethod_injective | congruence].
Qed.
Lemma addressingMethod_beq_refl x : addressingMethod_beq x x = true.
apply addressingMethod_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_addressingMethod : EqDecision addressingMethod := addressingMethod_eq_dec.
#[export]
Instance Countable_addressingMethod : Countable addressingMethod.
refine {|
  encode x := encode (num_of_addressingMethod x);
  decode x := z ← decode x; mret (addressingMethod_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite addressingMethod_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_addressingMethod : Inhabited addressingMethod := {
  inhabitant :=
    addressingMethod_E
}.


Definition mem_acc_is_explicit (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_RW).

Definition mem_acc_is_ifetch (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_IFETCH).

Definition mem_acc_is_ttw (acc : AccessDescriptor) : bool := false.

Definition mem_acc_is_relaxed (acc : AccessDescriptor) : bool := true.

Definition mem_acc_is_rel_acq_rcpc (acc : AccessDescriptor) : bool := false.

Definition mem_acc_is_rel_acq_rcsc (acc : AccessDescriptor) : bool := false.

Definition mem_acc_is_standalone (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_RW)))
     ((negb (acc.(AccessDescriptor_atomicop)))).

Definition mem_acc_is_exclusive (acc : AccessDescriptor) : bool := false.

Definition mem_acc_is_atomic_rmw (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_RW)))
     (acc.(AccessDescriptor_atomicop)).



Variant register_bitvector_64 :=
  | RIP
  | RAX
  | RCX
  | RDX
  | RBX
  | RSP
  | RBP
  | RSI
  | RDI
  | R8
  | R9
  | R10
  | R11
  | R12
  | R13
  | R14
  | R15
  | RFLAGS
.

Definition num_of_register_bitvector_64 (r : register_bitvector_64) : Z :=
  match r with
  | RIP => 0
  | RAX => 1
  | RCX => 2
  | RDX => 3
  | RBX => 4
  | RSP => 5
  | RBP => 6
  | RSI => 7
  | RDI => 8
  | R8 => 9
  | R9 => 10
  | R10 => 11
  | R11 => 12
  | R12 => 13
  | R13 => 14
  | R14 => 15
  | R15 => 16
  | RFLAGS => 17
  end.
Definition register_bitvector_64_of_num (i : Z) : register_bitvector_64 :=
  match i with
  | 0 => RIP
  | 1 => RAX
  | 2 => RCX
  | 3 => RDX
  | 4 => RBX
  | 5 => RSP
  | 6 => RBP
  | 7 => RSI
  | 8 => RDI
  | 9 => R8
  | 10 => R9
  | 11 => R10
  | 12 => R11
  | 13 => R12
  | 14 => R13
  | 15 => R14
  | 16 => R15
  | 17 => RFLAGS
  | _ => RIP
  end.
Lemma register_bitvector_64_num_of_roundtrip (x : register_bitvector_64) : register_bitvector_64_of_num (num_of_register_bitvector_64 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_64_injective (x y : register_bitvector_64) : num_of_register_bitvector_64 x = num_of_register_bitvector_64 y -> x = y.
  intro.
  rewrite <- (register_bitvector_64_num_of_roundtrip x).
  rewrite <- (register_bitvector_64_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_64_eq_dec (x y : register_bitvector_64) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y) with
  | left e => left (num_of_register_bitvector_64_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_64_beq (x y : register_bitvector_64) : bool :=
  Z.eqb (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y).
Lemma register_bitvector_64_beq_iff x y : register_bitvector_64_beq x y = true <-> x = y.
  unfold register_bitvector_64_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_64_injective | congruence].
Qed.
Lemma register_bitvector_64_beq_refl x : register_bitvector_64_beq x x = true.
apply register_bitvector_64_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_64_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_64_beq_refl : register_beq_refls.
Definition register_bitvector_64_list : list (string * register_bitvector_64) := [
  ("RIP", RIP);
  ("RAX", RAX);
  ("RCX", RCX);
  ("RDX", RDX);
  ("RBX", RBX);
  ("RSP", RSP);
  ("RBP", RBP);
  ("RSI", RSI);
  ("RDI", RDI);
  ("R8", R8);
  ("R9", R9);
  ("R10", R10);
  ("R11", R11);
  ("R12", R12);
  ("R13", R13);
  ("R14", R14);
  ("R15", R15);
  ("RFLAGS", RFLAGS)
].

Instance Decidable_eq_register_bitvector_64 : EqDecision register_bitvector_64 := register_bitvector_64_eq_dec.
Instance Countable_register_bitvector_64 : Countable register_bitvector_64. refine {|
  encode x := encode (num_of_register_bitvector_64 x);
  decode x := register_bitvector_64_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_64_num_of_roundtrip.
  reflexivity.
Defined.


Variant register : Type :=
  | R_bitvector_64 :> register_bitvector_64 -> register
.

Definition type_of_register (r : register) : Type :=
  match r with
  | R_bitvector_64 _ => ((mword 64))
  end.

  Definition register_encode (r : register) : positive :=
    match r with
    | R_bitvector_64 r => encode (0, encode r)
    end.
  Definition register_decode (x : positive) : option register :=
    match decode x with
    | Some (0, y) => r ← decode y; mret (R_bitvector_64 r)
    | _ => None
    end.
  Lemma register_decode_encode r : register_decode (register_encode r) = Some r.
  Proof.
    destruct r;
    unfold register_decode, register_encode;
    rewrite !decode_encode;
    reflexivity.
  Qed.
  Lemma register_encode_inj r r' : register_encode r = register_encode r' -> r = r'.
  Proof.
    intro H.
    enough (Some r = Some r') by congruence.
    rewrite <- (register_decode_encode r).
    rewrite <- (register_decode_encode r').
    congruence.
  Qed.
  #[export] Instance Decidable_eq_register : EqDecision register.
  refine (fun r r' => match Pos.eq_dec (register_encode r) (register_encode r') with
  | left e => left (register_encode_inj _ _ e)
  | right ne => right _
  end).
  congruence.
  Defined.
  #[export] Instance Countable_register : Countable register := {|
    encode := register_encode;
    decode := register_decode;
    decode_encode := register_decode_encode;
  |}.

Definition register_transport {P : Type -> Type} {r r' : register} : r = r' -> P (type_of_register r) -> P (type_of_register r').
refine (
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => fun _ x => x

  end
).
(* no wildcard case *)
Defined.

Lemma register_transport_sound {P} {r : register} (e : r = r) (p : P (type_of_register r)) :
  register_transport e p = p.
Proof.
  destruct r; reflexivity.
Qed.

Definition register_beq (r r' : register) : bool :=
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => register_bitvector_64_beq r r'

  end.

Lemma register_beq_refl (r : register) : register_beq r r = true.
destruct r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Definition register_eq_cast (P : Type -> Type) (r r' : register) : P (type_of_register r) -> option (P (type_of_register r')) :=
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => fun p => if register_bitvector_64_beq r r' then Some p else None

  end.

Definition register_list : list (string * register) := List.concat [
  List.map (fun '(s, r) => (s, R_bitvector_64 r)) register_bitvector_64_list
].

Definition string_of_register (r : register) : string :=
  match List.find (fun '(_s, r') => register_beq r r') register_list with
  | Some (s, _r) => s
  | None => "<impossible>"
  end.

Instance Pretty_register : Pretty register :=
  fun reg => string_of_register reg.

Definition register_of_string (s : string) : option register :=
  match List.find (fun '(s', _r) => String.eqb s s') register_list with
  | Some (_s, r) => Some r
  | None => None
  end.

Lemma string_of_register_roundtrip (r : register) :
  register_of_string (string_of_register r) = Some r.
case r; intro r'; destruct r'; reflexivity.
Qed.

#[export] Instance string_of_register_inj : Inj (=) (=) string_of_register.
Proof.
  intros r r' H.
  specialize (string_of_register_roundtrip r) as H1.
  specialize (string_of_register_roundtrip r') as H2.
  rewrite H in H1.
  rewrite H2 in H1.
  congruence.
Qed.
#[export] Hint Extern 1 (register _) => assumption : typeclass_instances.
#[export] Instance Decidable_eq_register_values `(r : register) : EqDecision (type_of_register r) | 100 :=
match r with
  | R_bitvector_64 _ => _
end.
#[export] Instance Inhabited_register_values `(r : register) : Inhabited (type_of_register r) | 100 :=
  match r with
  | R_bitvector_64 _ => _
end.
#[export] Instance Countable_register_values `(r : register) : Countable (type_of_register r) | 100.
refine {|
  encode := match r with
  | R_bitvector_64 _ => encode
  end;
  decode := match r with
  | R_bitvector_64 _ => decode
  end;
|}.
abstract (destruct r; apply decode_encode).
Defined.

Definition RIP_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RIP" RIP (fun x => x) (fun x => x).
Definition RAX_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RAX" RAX (fun x => x) (fun x => x).
Definition RCX_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RCX" RCX (fun x => x) (fun x => x).
Definition RDX_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RDX" RDX (fun x => x) (fun x => x).
Definition RBX_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RBX" RBX (fun x => x) (fun x => x).
Definition RSP_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RSP" RSP (fun x => x) (fun x => x).
Definition RBP_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RBP" RBP (fun x => x) (fun x => x).
Definition RSI_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RSI" RSI (fun x => x) (fun x => x).
Definition RDI_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RDI" RDI (fun x => x) (fun x => x).
Definition R8_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R8" R8 (fun x => x) (fun x => x).
Definition R9_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R9" R9 (fun x => x) (fun x => x).
Definition R10_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R10" R10 (fun x => x) (fun x => x).
Definition R11_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R11" R11 (fun x => x) (fun x => x).
Definition R12_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R12" R12 (fun x => x) (fun x => x).
Definition R13_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R13" R13 (fun x => x) (fun x => x).
Definition R14_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R14" R14 (fun x => x) (fun x => x).
Definition R15_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "R15" R15 (fun x => x) (fun x => x).
Definition RFLAGS_ref : register_ref _ :=
  Build_register_ref register type_of_register _ "RFLAGS" RFLAGS (fun x => x) (fun x => x).
Instance dummy_register_bitvector_64 : Inhabited (register_ref _) := populate RIP_ref.


(* Definitions to support the lifting to the sequential monad *)
Record regstate := {
  bitvector_64_s : register_bitvector_64 -> mword 64;
}.
#[export] Instance eta_regstate : Settable _ := settable! Build_regstate <bitvector_64_s>.

Definition init_regstate : regstate := Build_regstate
  inhabitant
.

Definition register_lookup (reg : register) (rs : regstate) : type_of_register reg :=
  match reg with
  | R_bitvector_64 r => rs.(bitvector_64_s) r
  end.

Definition register_set (reg : register) : type_of_register reg -> regstate -> regstate :=
  match reg with
  | R_bitvector_64 r => fun v rs => rs <|bitvector_64_s := fun r' => if register_bitvector_64_beq r' r then v else rs.(bitvector_64_s) r'|>
  end.

Lemma register_lookup_set (r : register) regs v: register_lookup r (register_set r v regs) = v.
destruct regs, r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Lemma irrelevant_register_set (r r' : register) regs v:
  register_beq r r' = false ->
  register_lookup r (register_set r' v regs) = register_lookup r regs.
destruct regs, r, r'; simpl; intro EQ; rewrite ?EQ; reflexivity.
Qed.

Arguments register_set : simpl never.
Arguments register_lookup : simpl never.

Definition register_accessors : register_accessors regstate register type_of_register := (@register_lookup, @register_set).


(* Instantiate library definitions with types. *)

Definition read_reg {E} := @read_reg register type_of_register E.
Definition write_reg {E} := @write_reg register type_of_register E.

Module Arch <: Arch.
  Definition reg : Type := register.
  #[global] Typeclasses Transparent reg.
  Definition reg_eq := @Decidable_eq_register.
  Definition reg_countable := @Countable_register.
  Definition reg_pretty := @Pretty_register.
  Definition reg_type := type_of_register.
  Definition reg_type_eq := @Decidable_eq_register_values.
  Definition reg_type_countable := @Countable_register_values.
  Definition reg_type_inhabited := @Inhabited_register_values.
  Definition regval_transport := @register_transport (fun x => x).
  Definition regval_transport_sound := @register_transport_sound (fun x => x).
  Definition addr_size : N := Z.to_N (64).
  Definition addr_space : Type := unit.
  Definition addr_space_eq : EqDecision addr_space := _.
  Definition addr_space_countable : Countable addr_space := _.
  Definition mem_acc : Type := AccessDescriptor.
  Definition mem_acc_eq : EqDecision mem_acc := _.
  Definition mem_acc_countable : Countable mem_acc := _.
  Definition CHERI : bool := (false).
  Definition cap_size_log : N := 0.
  Definition mem_acc_is_explicit := mem_acc_is_explicit.
  Definition mem_acc_is_ifetch := mem_acc_is_ifetch.
  Definition mem_acc_is_ttw := mem_acc_is_ttw.
  Definition mem_acc_is_relaxed := mem_acc_is_relaxed.
  Definition mem_acc_is_rel_acq_rcpc := mem_acc_is_rel_acq_rcpc.
  Definition mem_acc_is_rel_acq_rcsc := mem_acc_is_rel_acq_rcsc.
  Definition mem_acc_is_standalone := mem_acc_is_standalone.
  Definition mem_acc_is_exclusive := mem_acc_is_exclusive.
  Definition mem_acc_is_atomic_rmw := mem_acc_is_atomic_rmw.
  Definition trans_start : Type := unit.
  Definition trans_start_eq : EqDecision trans_start := _.
  Definition trans_start_countable : Countable trans_start := _.
  Definition trans_end : Type := unit.
  Definition trans_end_eq : EqDecision trans_end := _.
  Definition trans_end_countable : Countable trans_end := _.
  Definition abort : Type := unit.
  Definition abort_eq : EqDecision abort := _.
  Definition abort_countable : Countable abort := _.
  Definition barrier : Type := Barrier.
  Definition barrier_eq : EqDecision barrier := _.
  Definition barrier_countable : Countable barrier := _.
  Definition cache_op : Type := unit.
  Definition cache_op_eq : EqDecision cache_op := _.
  Definition cache_op_countable : Countable cache_op := _.
  Definition tlbi : Type := unit.
  Definition tlbi_eq : EqDecision tlbi := _.
  Definition tlbi_countable : Countable tlbi := _.
  Definition exn : Type := unit.
  Definition exn_eq : EqDecision exn := _.
  Definition exn_countable : Countable exn := _.
  Definition sys_reg_id : Type := unit.
  Definition sys_reg_id_eq : EqDecision sys_reg_id := _.
  Definition sys_reg_id_countable : Countable sys_reg_id := _.
End Arch.

Module Interface := Interface Arch.
Module Defs := Defs Arch Interface.

Definition M := Defs.monad unit.
Definition MR r := Defs.monad (r + unit)%type.
Definition returnM {A:Type} : A -> M A := Defs.returnm (E := unit).
Definition returnR {A:Type} (R:Type) : A -> MR R A := Defs.returnm (E := R + unit)%type.
Definition register_ref := @register_ref register type_of_register.