(*Generated by Sail from Tiny_x86.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
Require Import Tiny_x86_types.
Import Defs.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition neq_int (x : Z) (y : Z) : bool := negb ((Z.eqb (x) (y))).

Definition neq_bool (x : bool) (y : bool) : bool := negb ((Bool.eqb (x) (y))).

Definition eq_bits_int {n : Z} (x : mword n) (y : Z) (*(n >=? 0) && (y >=? 0)*) : bool :=
   Z.eqb ((uint (x))) (y).

Definition __id (x : Z) : Z := x.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shl_int (m) (n) else shr_int (m) ((Z.opp (n))).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shr_int (m) (n) else shl_int (m) ((Z.opp (n))).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb ((Z.ltb (n) (0))) ((Z.gtb (m) (0))) then Z.sub ((Z.quot ((Z.add (n) (1))) (m))) (1)
   else if andb ((Z.gtb (n) (0))) ((Z.ltb (m) (0))) then Z.sub ((Z.quot ((Z.sub (n) (1))) (m))) (1)
   else Z.quot (n) (m).

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub (n) ((Z.mul (m) ((fdiv_int (n) (m))))).

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb (len) v0 then vector_truncate (v) (len) else zero_extend (v) (len).

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec ((zeros (n))).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb (l) (n) then shiftl ((sail_ones (n))) (i)
   else
     let one : bits n := sail_mask (n) ((('b"1")  : bits 1)) in
     shiftl ((sub_vec ((shiftl (one) (l))) (one))) (i).

Definition to_bytes_le (n : Z) (b : mword (8 * n)) (*n >? 0*) : vec (mword 8) n :=
   let res := vector_init (n) ((zeros (8))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       vec_update_dec (res) (i)
         ((autocast (T := mword)
           (subrange_vec_dec (b) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))))))).

Definition from_bytes_le (n : Z) (v : vec (mword 8) n) (*n >? 0*) : mword (8 * n) :=
   let res := zeros ((Z.mul (8) (n))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       update_subrange_vec_dec (res) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))
         ((autocast (T := mword)
           (vec_access_dec (v) (i)))))).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append (str) ((string_of_bits (x))).

Definition concat_str_dec (str : string) (x : Z) : string := String.append (str) ((dec_str (x))).

Definition reverse_endianness {n : Z} (xs : mword n) (*member_Z_list n [8; 16; 32; 64; 128]*)
: mword n :=
   let len := length_mword (xs) in
   if Z.eqb n (8) then xs
   else if Z.eqb n (16) then
     autocast (T := mword)
     (concat_vec ((subrange_vec_dec (xs) (7) (0))) ((subrange_vec_dec (xs) (15) (8))))
   else if Z.eqb n (32) then
     autocast (T := mword)
     (concat_vec ((subrange_vec_dec (xs) (7) (0)))
        ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
            ((concat_vec ((subrange_vec_dec (xs) (23) (16))) ((subrange_vec_dec (xs) (31) (24))))))))
   else if Z.eqb n (64) then
     autocast (T := mword)
     (concat_vec ((subrange_vec_dec (xs) (7) (0)))
        ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
            ((concat_vec ((subrange_vec_dec (xs) (23) (16)))
                ((concat_vec ((subrange_vec_dec (xs) (31) (24)))
                    ((concat_vec ((subrange_vec_dec (xs) (39) (32)))
                        ((concat_vec ((subrange_vec_dec (xs) (47) (40)))
                            ((concat_vec ((subrange_vec_dec (xs) (55) (48)))
                                ((subrange_vec_dec (xs) (63) (56))))))))))))))))
   else
     autocast (T := mword)
     (concat_vec ((subrange_vec_dec (xs) (7) (0)))
        ((concat_vec ((subrange_vec_dec (xs) (15) (8)))
            ((concat_vec ((subrange_vec_dec (xs) (23) (16)))
                ((concat_vec ((subrange_vec_dec (xs) (31) (24)))
                    ((concat_vec ((subrange_vec_dec (xs) (39) (32)))
                        ((concat_vec ((subrange_vec_dec (xs) (47) (40)))
                            ((concat_vec ((subrange_vec_dec (xs) (55) (48)))
                                ((concat_vec ((subrange_vec_dec (xs) (63) (56)))
                                    ((concat_vec ((subrange_vec_dec (xs) (71) (64)))
                                        ((concat_vec ((subrange_vec_dec (xs) (79) (72)))
                                            ((concat_vec ((subrange_vec_dec (xs) (87) (80)))
                                                ((concat_vec ((subrange_vec_dec (xs) (95) (88)))
                                                    ((concat_vec
                                                        ((subrange_vec_dec (xs) (103) (96)))
                                                        ((concat_vec
                                                            ((subrange_vec_dec (xs) (111) (104)))
                                                            ((concat_vec
                                                                ((subrange_vec_dec (xs) (119) (112)))
                                                                ((subrange_vec_dec (xs) (127) (120)))))))))))))))))))))))))))))))).

Definition mod' (x : Z) (y : Z) : Z := Z.rem (x) (y).

Definition fail {a : Type} (message : string) : M (a) :=
   assert_exp' false message >>= fun _ => exit tt.

Definition flip_bit (bit_to_flip : bitU) : bitU := if eq_bit (bit_to_flip) (B0) then B1 else B0.

Definition GPRs : vec (register_ref (bits 64)) 16 :=
vec_of_list_len [R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;R10_ref;R9_ref;R8_ref;RDI_ref;RSI_ref;
                 RBP_ref;RSP_ref;RBX_ref;RDX_ref;RCX_ref;RAX_ref].
#[export] Hint Unfold GPRs : sail.
Definition undefined_rflags '(tt : unit) : M (mword 64) :=
   (undefined_bitvector (64))  : M (mword 64).

Definition Mk_rflags (v : mword 64) : mword 64 := v.

Definition _get_rflags_bits (v : mword 64) : mword 64 :=
   subrange_vec_dec (v) ((Z.sub (64) (1))) (0).

Definition _update_rflags_bits (v : mword 64) (x : mword 64) : mword 64 :=
   update_subrange_vec_dec (v) ((Z.sub (64) (1))) (0) (x).

Definition _update_REX_bits (v : mword 8) (x : mword 8) : mword 8 :=
   update_subrange_vec_dec (v) ((Z.sub (8) (1))) (0) (x).

Definition _update_SIBByte_bits (v : mword 8) (x : mword 8) : mword 8 :=
   update_subrange_vec_dec (v) ((Z.sub (8) (1))) (0) (x).

Definition _update_modRMByte_bits (v : mword 8) (x : mword 8) : mword 8 :=
   update_subrange_vec_dec (v) ((Z.sub (8) (1))) (0) (x).

Definition _set_rflags_bits (r_ref : register_ref (mword 64)) (v : mword 64) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_bits (r) (v))  : M (unit).

Definition _get_REX_bits (v : mword 8) : mword 8 := subrange_vec_dec (v) ((Z.sub (8) (1))) (0).

Definition _get_SIBByte_bits (v : mword 8) : mword 8 := subrange_vec_dec (v) ((Z.sub (8) (1))) (0).

Definition _get_modRMByte_bits (v : mword 8) : mword 8 :=
   subrange_vec_dec (v) ((Z.sub (8) (1))) (0).

Definition _set_REX_bits (r_ref : register_ref (mword 8)) (v : mword 8) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_REX_bits (r) (v))  : M (unit).

Definition _set_SIBByte_bits (r_ref : register_ref (mword 8)) (v : mword 8) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SIBByte_bits (r) (v))  : M (unit).

Definition _set_modRMByte_bits (r_ref : register_ref (mword 8)) (v : mword 8) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_modRMByte_bits (r) (v))  : M (unit).

Definition _get_rflags_AF (v : mword 64) : mword 1 := subrange_vec_dec (v) (4) (4).

Definition _update_rflags_AF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (4) (4) (x).

Definition _set_rflags_AF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_AF (r) (v))  : M (unit).

Definition _get_rflags_CF (v : mword 64) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_rflags_CF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_rflags_CF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_CF (r) (v))  : M (unit).

Definition _get_rflags_OF (v : mword 64) : mword 1 := subrange_vec_dec (v) (11) (11).

Definition _update_rflags_OF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (11) (11) (x).

Definition _set_rflags_OF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_OF (r) (v))  : M (unit).

Definition _get_rflags_PF (v : mword 64) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _update_rflags_PF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _set_rflags_PF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_PF (r) (v))  : M (unit).

Definition _get_rflags_SF (v : mword 64) : mword 1 := subrange_vec_dec (v) (7) (7).

Definition _update_rflags_SF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (7) (7) (x).

Definition _set_rflags_SF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_SF (r) (v))  : M (unit).

Definition _get_rflags_ZF (v : mword 64) : mword 1 := subrange_vec_dec (v) (6) (6).

Definition _update_rflags_ZF (v : mword 64) (x : mword 1) : mword 64 :=
   update_subrange_vec_dec (v) (6) (6) (x).

Definition _set_rflags_ZF (r_ref : register_ref (mword 64)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_rflags_ZF (r) (v))  : M (unit).

Definition read_GPR (operand_size : Z) (reg : reg) (*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   match reg with
   | REG_NORMAL i =>
      (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun reg =>
      returnM ((autocast (T := mword) (subrange_vec_dec (reg) ((Z.sub (operand_size) (1))) (0))))
   | REG_HIGH_BYTE i =>
      assert_exp' (Z.eqb (operand_size) (8)) "Register is high byte enabled but operand size is not 8 bits" >>= fun _ =>
      (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun reg =>
      returnM ((autocast (T := mword) (subrange_vec_dec (reg) (15) (8))))
   end
    : M (mword operand_size).

Definition write_GPR (operand_size : Z) (reg : reg) (value : mword operand_size)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   match reg with
   | REG_NORMAL i =>
      (if Z.eqb (operand_size) (32) return M (unit) then
         (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun (w__0 : mword 64) =>
         write_reg_ref
           (vec_access_dec (GPRs) (i))
           (update_subrange_vec_dec (w__0) (63) (32) (((Ox"00000000")  : mword 32))) >>
         (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun (w__1 : mword 64) =>
         write_reg_ref
           (vec_access_dec (GPRs) (i))
           (update_subrange_vec_dec (w__1) (31) (0) ((autocast (T := mword)  value)))
          : M (unit)
       else
         (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun (w__2 : mword 64) =>
         write_reg_ref
           (vec_access_dec (GPRs) (i))
           (update_subrange_vec_dec (w__2) ((Z.sub (operand_size) (1))) (0)
              ((autocast (T := mword) 
              value)))
          : M (unit))
       : M (unit)
   | REG_HIGH_BYTE i =>
      assert_exp' (Z.eqb (operand_size) (8)) "Register is high byte enabled but operand size is not 8 bits" >>= fun _ =>
      (reg_deref ((vec_access_dec (GPRs) (i)))) >>= fun (w__3 : mword 64) =>
      write_reg_ref
        (vec_access_dec (GPRs) (i))
        (update_subrange_vec_dec (w__3) (15) (8) ((autocast (T := mword)  value)))
       : M (unit)
   end
    : M (unit).

Definition update_sign_flag (operand_size : Z) (result' : mword operand_size) (*operand_size >? 0*)
: M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (7) (7)
        ((vec_of_bits [access_vec_dec (result') ((Z.sub (operand_size) (1)))]  : mword 1)))
    : M (unit).

Definition update_overflow_flag_add_inner (first_msb : bitU) (second_msb : bitU) (result_msb : bitU)
: M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (11) (11)
        ((if andb ((eq_bit (first_msb) (second_msb))) ((negb ((eq_bit (result_msb) (first_msb)))))
          then
            ('b"1")
             : mword 1
          else ('b"0")  : mword 1)))
    : M (unit).

Definition update_overflow_flag_sub
(size : Z) (first : mword size) (second : mword size) (result' : mword size) (*size >? 0*)
: M (unit) :=
   (update_overflow_flag_add_inner ((access_vec_dec (first) ((Z.sub (size) (1)))))
      ((flip_bit ((access_vec_dec (second) ((Z.sub (size) (1)))))))
      ((access_vec_dec (result') ((Z.sub (size) (1))))))
    : M (unit).

Definition update_overflow_flag_add
(size : Z) (first : mword size) (second : mword size) (result' : mword size) (*size >? 0*)
: M (unit) :=
   (update_overflow_flag_add_inner ((access_vec_dec (first) ((Z.sub (size) (1)))))
      ((access_vec_dec (second) ((Z.sub (size) (1)))))
      ((access_vec_dec (result') ((Z.sub (size) (1))))))
    : M (unit).

Definition update_carry_flag_sub {m : Z} (first : mword m) (second : mword m) (*m >? 0*) : M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (0) (0)
        ((if Z.ltb ((uint (first))) ((uint (second))) then ('b"1")  : mword 1
          else ('b"0")  : mword 1)))
    : M (unit).

Definition update_carry_flag_add (size : Z) (first : mword size) (second : mword size) (*size >? 0*)
: M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (0) (0)
        ((if Z.gtb ((Z.add ((uint (first))) ((uint (second))))) ((Z.sub ((pow2 (size))) (1))) then
            ('b"1")
             : mword 1
          else ('b"0")  : mword 1)))
    : M (unit).

Definition update_aux_carry_flag_sub {m : Z} (first : mword m) (second : mword m) (*m >=? 4*)
: M (unit) :=
   (update_carry_flag_sub ((subrange_vec_dec (first) (3) (0))) ((subrange_vec_dec (second) (3) (0))))
    : M (unit).

Definition update_aux_carry_flag_add {m : Z} (first : mword m) (second : mword m) (*m >=? 4*)
: M (unit) :=
   (update_carry_flag_add ((Z.add ((Z.sub (3) (0))) (1))) ((subrange_vec_dec (first) (3) (0)))
      ((subrange_vec_dec (second) (3) (0))))
    : M (unit).

Definition update_zero_flag (operand_size : Z) (result' : mword operand_size) (*operand_size >=? 8*)
: M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (6) (6)
        ((if eq_vec (result') ((zero_extend (((Ox"0")  : mword 4)) (operand_size))) then
            ('b"1")
             : mword 1
          else ('b"0")  : mword 1)))
    : M (unit).

Definition update_parity_flag {m : Z} (result' : mword m) (*m >=? 8*) : M (unit) :=
   let even_parity := B1 in
   let even_parity : bitU :=
     let '(loop_i_lower) := 0 in
     let '(loop_i_upper) := 7 in
     (foreach_Z_up loop_i_lower loop_i_upper 1 even_parity
       (fun i even_parity =>
         if eq_bit ((access_vec_dec (result') (i))) (B1) then flip_bit (even_parity)
         else even_parity)) in
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg
     RFLAGS
     (update_subrange_vec_dec (w__0) (2) (2) ((vec_of_bits [even_parity]  : mword 1)))
    : M (unit).

Definition update_RFLAGS_sub {m : Z} (first : mword m) (second : mword m) (result' : mword m)
(*m >=? 8*)
: M (unit) :=
   (update_sign_flag m (result')) >>
   (update_overflow_flag_sub m (first) (second) (result')) >>
   (update_carry_flag_sub (first) (second)) >>
   (update_zero_flag m (result')) >>
   (update_aux_carry_flag_sub (first) (second)) >> (update_parity_flag (result'))  : M (unit).

Definition update_RFLAGS_add {m : Z} (first : mword m) (second : mword m) (result' : mword m)
(*m >=? 8*)
: M (unit) :=
   (update_sign_flag m (result')) >>
   (update_overflow_flag_add m (first) (second) (result')) >>
   (update_carry_flag_add m (first) (second)) >>
   (update_zero_flag m (result')) >>
   (update_aux_carry_flag_add (first) (second)) >> (update_parity_flag (result'))  : M (unit).

Definition is_ok {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => true | Err _ => false end.

Definition is_err {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => false | Err _ => true end.

Definition ok_option {a : Type} {b : Type} (r : result a b) : option a :=
   match r with | Ok x => Some (x) | Err _ => None end.

Definition err_option {a : Type} {b : Type} (r : result a b) : option b :=
   match r with | Ok _ => None | Err err => Some (err) end.

Definition unwrap_or {a : Type} {b : Type} (r : result a b) (y : a) : a :=
   match r with | Ok x => x | Err _ => y end.

Definition sail_instr_announce {n : Z} (_ : mword n) (*n >? 0*) : unit := tt.

Definition sail_branch_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition sail_reset_registers '(tt : unit) : unit := tt.

Definition sail_synchronize_registers '(tt : unit) : unit := tt.

Definition sail_mark_register {a : Type} (_ : register_ref a) (_ : string) : unit := tt.

Definition sail_mark_register_pair {a : Type} {b : Type}
(_ : register_ref a) (_ : register_ref b) (_ : string)
: unit :=
   tt.

Definition sail_ignore_write_to {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("ignore_write").

Definition sail_pick_dependency {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("pick").

Definition __monomorphize {n : Z} (bv : mword n) (*n >=? 0*) : mword n := bv.

Definition __monomorphize_int (n : Z) : Z := n.

Definition __monomorphize_bool (b : bool) : bool := b.

Definition __monomorphize_reads : bool := false.
#[export] Hint Unfold __monomorphize_reads : sail.
Definition __monomorphize_writes : bool := false.
#[export] Hint Unfold __monomorphize_writes : sail.
Definition sail_address_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition undefined_AccessType '(tt : unit) : M (AccessType) :=
   (internal_pick ([AccessType_IFETCH; AccessType_RW]))  : M (AccessType).

Definition undefined_AccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   returnM (({| AccessDescriptor_acctype := w__0;
                AccessDescriptor_atomicop := w__1;
                AccessDescriptor_read := w__2;
                AccessDescriptor_write := w__3 |})).

Definition base_AccessDescriptor (acctype : AccessType) : AccessDescriptor :=
   {| AccessDescriptor_acctype := acctype;
      AccessDescriptor_atomicop := false;
      AccessDescriptor_read := false;
      AccessDescriptor_write := false |}.

Definition create_iFetchAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := base_AccessDescriptor (AccessType_IFETCH) in
   accdesc
   <|AccessDescriptor_read := true|>.

Definition create_readAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := base_AccessDescriptor (AccessType_RW) in
   accdesc
   <|AccessDescriptor_read := true|>.

Definition create_writeAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := base_AccessDescriptor (AccessType_RW) in
   accdesc
   <|AccessDescriptor_write := true|>.

Definition create_atomicReadAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := create_readAccessDescriptor (tt) in
   accdesc
   <|AccessDescriptor_atomicop := true|>.

Definition create_atomicWriteAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := create_writeAccessDescriptor (tt) in
   accdesc
   <|AccessDescriptor_atomicop := true|>.

Definition read_memory (N : Z) (addr : mword 64) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (8 * N)) :=
   let req : Mem_request N 0 64 unit AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (64);
        Mem_request_address_space := tt;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_read (req)) >>= fun (w__0 : result ((vec (mword 8) N * vec bool 0)) unit) =>
   match w__0 with
   | Ok (bytes, _) => returnM ((from_bytes_le ((__id (N))) (bytes)))
   | Err _e => exit tt  : M (mword (8 * N))
   end
    : M (mword (8 * N)).

Definition write_memory
(N : Z) (addr : mword 64) (value : mword (8 * N)) (accdesc : AccessDescriptor) (*N >? 0*)
: M (unit) :=
   let req : Mem_request N 0 64 unit AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (64);
        Mem_request_address_space := tt;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_write (req) ((to_bytes_le (N) (value))) ((vec_of_list_len []))) >>= fun (w__0 : result unit unit) =>
   match w__0 with | Ok _ => returnM (tt) | Err _ => exit tt  : M (unit) end
    : M (unit).

Definition undefined_Barrier '(tt : unit) : M (Barrier) :=
   (internal_pick ([Barrier_SFENCE; Barrier_LFENCE; Barrier_MFENCE]))  : M (Barrier).

Definition read_imm (operand_size : Z) (imm : imm) (*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   match imm with
   | IMM8 value =>
      assert_exp' (Z.eqb (operand_size) (8)) "Immediate value size is 8 bits, but operand size is not." >>= fun _ =>
      returnM ((autocast (T := mword)  value))
   | IMM16 value =>
      assert_exp' (Z.eqb (operand_size) (16)) "Immediate value size is 16 bits, but operand size is not." >>= fun _ =>
      returnM ((autocast (T := mword)  value))
   | IMM32 value =>
      assert_exp' (Z.geb (operand_size) (32)) "Immediate value size is 32 bits, but operand size is not 32 or 64 bits." >>= fun _ =>
      returnM ((sign_extend (value) (operand_size)))
   | IMM64 value =>
      assert_exp' (Z.eqb (operand_size) (64)) "Immediate value size is 64 bits, but operand size is not." >>= fun _ =>
      returnM ((autocast (T := mword)  value))
   end
    : M (mword operand_size).

Definition read_rm_operand_with_lock (lock : bool) (operand_size : Z) (operand : rm_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   match operand with
   | rm_REG reg => (read_GPR (operand_size) (reg))  : M (mword operand_size)
   | rm_MEM mem_addr =>
      let acc_desc :=
        if lock then create_atomicReadAccessDescriptor (tt)
        else create_readAccessDescriptor (tt) in
      let operand_size_bytes := Z.quot (operand_size) (8) in
      assert_exp' (Z.eqb (operand_size) ((Z.mul (operand_size_bytes) (8)))) "operands.sail:64.57-64.58" >>= fun _ =>
      autocast_m (T := mword) ((read_memory _ (mem_addr) (acc_desc))
       : M (mword (8 * ZEuclid.div operand_size 8)))
   end
    : M (mword operand_size).

Definition read_rm_operand_without_lock (operand_size : Z) (operand : rm_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   (read_rm_operand_with_lock (false) (operand_size) (operand))  : M (mword operand_size).

Definition read_rmi_operand_with_lock (lock : bool) (operand_size : Z) (operand : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   match operand with
   | rmi_IMM imm => (read_imm (operand_size) (imm))  : M (mword operand_size)
   | rmi_REG reg => (read_GPR (operand_size) (reg))  : M (mword operand_size)
   | rmi_MEM mem_addr =>
      let acc_desc :=
        if lock then create_atomicReadAccessDescriptor (tt)
        else create_readAccessDescriptor (tt) in
      let operand_size_bytes := Z.quot (operand_size) (8) in
      assert_exp' (Z.eqb (operand_size) ((Z.mul (operand_size_bytes) (8)))) "operands.sail:84.57-84.58" >>= fun _ =>
      autocast_m (T := mword) ((read_memory _ (mem_addr) (acc_desc))
       : M (mword (8 * ZEuclid.div operand_size 8)))
   end
    : M (mword operand_size).

Definition read_rmi_operand_without_lock (operand_size : Z) (operand : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (mword operand_size) :=
   (read_rmi_operand_with_lock (false) (operand_size) (operand))  : M (mword operand_size).

Definition write_rm_operand_with_lock
(lock : bool) (operand_size : Z) (operand : rm_operand) (value : mword operand_size)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   match operand with
   | rm_REG reg => (write_GPR (operand_size) (reg) (value))  : M (unit)
   | rm_MEM mem_addr =>
      let acc_desc :=
        if lock then create_atomicWriteAccessDescriptor (tt)
        else create_writeAccessDescriptor (tt) in
      let operand_size_bytes := Z.quot (operand_size) (8) in
      assert_exp' (Z.eqb (operand_size) ((Z.mul (operand_size_bytes) (8)))) "operands.sail:111.57-111.58" >>= fun _ =>
      (write_memory (operand_size_bytes) (mem_addr) ((autocast (T := mword)  value)) (acc_desc))
       : M (unit)
   end
    : M (unit).

Definition write_rm_operand_without_lock
(operand_size : Z) (operand : rm_operand) (value : mword operand_size)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (write_rm_operand_with_lock (false) (operand_size) (operand) (value))  : M (unit).

Definition undefined_REX '(tt : unit) : M (mword 8) := (undefined_bitvector (8))  : M (mword 8).

Definition Mk_REX (v : mword 8) : mword 8 := v.

Definition _get_REX_B (v : mword 8) : mword 1 := subrange_vec_dec (v) (0) (0).

Definition _update_REX_B (v : mword 8) (x : mword 1) : mword 8 :=
   update_subrange_vec_dec (v) (0) (0) (x).

Definition _set_REX_B (r_ref : register_ref (mword 8)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_REX_B (r) (v))  : M (unit).

Definition _get_REX_R (v : mword 8) : mword 1 := subrange_vec_dec (v) (2) (2).

Definition _update_REX_R (v : mword 8) (x : mword 1) : mword 8 :=
   update_subrange_vec_dec (v) (2) (2) (x).

Definition _set_REX_R (r_ref : register_ref (mword 8)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_REX_R (r) (v))  : M (unit).

Definition _get_REX_W (v : mword 8) : mword 1 := subrange_vec_dec (v) (3) (3).

Definition _update_REX_W (v : mword 8) (x : mword 1) : mword 8 :=
   update_subrange_vec_dec (v) (3) (3) (x).

Definition _set_REX_W (r_ref : register_ref (mword 8)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_REX_W (r) (v))  : M (unit).

Definition _get_REX_X (v : mword 8) : mword 1 := subrange_vec_dec (v) (1) (1).

Definition _update_REX_X (v : mword 8) (x : mword 1) : mword 8 :=
   update_subrange_vec_dec (v) (1) (1) (x).

Definition _set_REX_X (r_ref : register_ref (mword 8)) (v : mword 1) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_REX_X (r) (v))  : M (unit).

Definition undefined_modRMByte '(tt : unit) : M (mword 8) :=
   (undefined_bitvector (8))  : M (mword 8).

Definition Mk_modRMByte (v : mword 8) : mword 8 := v.

Definition _get_modRMByte_Mod (v : mword 8) : mword 2 := subrange_vec_dec (v) (7) (6).

Definition _update_modRMByte_Mod (v : mword 8) (x : mword 2) : mword 8 :=
   update_subrange_vec_dec (v) (7) (6) (x).

Definition _set_modRMByte_Mod (r_ref : register_ref (mword 8)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_modRMByte_Mod (r) (v))  : M (unit).

Definition _get_modRMByte_REG (v : mword 8) : mword 3 := subrange_vec_dec (v) (5) (3).

Definition _update_modRMByte_REG (v : mword 8) (x : mword 3) : mword 8 :=
   update_subrange_vec_dec (v) (5) (3) (x).

Definition _set_modRMByte_REG (r_ref : register_ref (mword 8)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_modRMByte_REG (r) (v))  : M (unit).

Definition _get_modRMByte_RM (v : mword 8) : mword 3 := subrange_vec_dec (v) (2) (0).

Definition _update_modRMByte_RM (v : mword 8) (x : mword 3) : mword 8 :=
   update_subrange_vec_dec (v) (2) (0) (x).

Definition _set_modRMByte_RM (r_ref : register_ref (mword 8)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_modRMByte_RM (r) (v))  : M (unit).

Definition undefined_SIBByte '(tt : unit) : M (mword 8) := (undefined_bitvector (8))  : M (mword 8).

Definition Mk_SIBByte (v : mword 8) : mword 8 := v.

Definition _get_SIBByte_Base (v : mword 8) : mword 3 := subrange_vec_dec (v) (2) (0).

Definition _update_SIBByte_Base (v : mword 8) (x : mword 3) : mword 8 :=
   update_subrange_vec_dec (v) (2) (0) (x).

Definition _set_SIBByte_Base (r_ref : register_ref (mword 8)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SIBByte_Base (r) (v))  : M (unit).

Definition _get_SIBByte_Index (v : mword 8) : mword 3 := subrange_vec_dec (v) (5) (3).

Definition _update_SIBByte_Index (v : mword 8) (x : mword 3) : mword 8 :=
   update_subrange_vec_dec (v) (5) (3) (x).

Definition _set_SIBByte_Index (r_ref : register_ref (mword 8)) (v : mword 3) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SIBByte_Index (r) (v))  : M (unit).

Definition _get_SIBByte_Scale (v : mword 8) : mword 2 := subrange_vec_dec (v) (7) (6).

Definition _update_SIBByte_Scale (v : mword 8) (x : mword 2) : mword 8 :=
   update_subrange_vec_dec (v) (7) (6) (x).

Definition _set_SIBByte_Scale (r_ref : register_ref (mword 8)) (v : mword 2) : M (unit) :=
   (reg_deref (r_ref)) >>= fun r => write_reg_ref r_ref (_update_SIBByte_Scale (r) (v))  : M (unit).

Definition undefined_decodedPrefixes '(tt : unit) : M (decodedPrefixes) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_REX (tt)) >>= fun (w__3 : mword 8) =>
   returnM (({| decodedPrefixes_lock := w__0;
                decodedPrefixes_op_size_override := w__1;
                decodedPrefixes_mandatory_prefix_66H := w__2;
                decodedPrefixes_REX := w__3 |})).

Definition undefined_addressingMethod '(tt : unit) : M (addressingMethod) :=
   (internal_pick ([addressingMethod_E; addressingMethod_G]))  : M (addressingMethod).

Definition reset_prefixes_not_at_end (decoded_prefixes : decodedPrefixes) : decodedPrefixes :=
   decoded_prefixes
   <|decodedPrefixes_mandatory_prefix_66H := false|>
   <|decodedPrefixes_REX := (Ox"00")  : mword 8|>.

Fixpoint _rec_decode_prefix_inner
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
(prev_prefix : mword 8) (max_iters : Z) (_reclimit : Z) (_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M ((Z * decodedPrefixes)).
exact (
   assert_exp' (Z.geb (_reclimit) (0)) "recursion limit reached" >>= fun _ =>
   (if Z.eqb (max_iters) (0) then returnM ((read_offset, decoded_prefixes))
    else
      (read_memory (1) ((add_vec_int (instruction_ptr) (read_offset)))
         ((create_iFetchAccessDescriptor (tt)))) >>= fun (next_prefix : bits 8) =>
      (if eq_vec (next_prefix) (((Ox"F0")  : mword 8)) return M ((Z * decodedPrefixes)) then
         let reset_decoded_prefixes := reset_prefixes_not_at_end (decoded_prefixes) in
         let new_decoded_prefixes := reset_decoded_prefixes <|decodedPrefixes_lock := true|> in
         (_rec_decode_prefix_inner (instruction_ptr) ((Z.add (read_offset) (1)))
            (new_decoded_prefixes) (next_prefix) ((Z.sub (max_iters) (1))) ((Z.sub (_reclimit) (1)))
            (_limit_reduces_bool _acc ltac:(assumption)))
          : M ((Z * decodedPrefixes))
       else if eq_vec (next_prefix) (((Ox"66")  : mword 8)) return M ((Z * decodedPrefixes)) then
         let reset_decoded_prefixes := reset_prefixes_not_at_end (decoded_prefixes) in
         let new_decoded_prefixes :=
           reset_decoded_prefixes
           <|decodedPrefixes_op_size_override := true|>
           <|decodedPrefixes_mandatory_prefix_66H := true|> in
         (_rec_decode_prefix_inner (instruction_ptr) ((Z.add (read_offset) (1)))
            (new_decoded_prefixes) (next_prefix) ((Z.sub (max_iters) (1))) ((Z.sub (_reclimit) (1)))
            (_limit_reduces_bool _acc ltac:(assumption)))
          : M ((Z * decodedPrefixes))
       else if eq_vec ((subrange_vec_dec (next_prefix) (7) (4))) (((Ox"4")  : mword 4))
         return
         M ((Z * decodedPrefixes)) then
         let reset_decoded_prefixes :=
           if eq_vec (prev_prefix) (((Ox"66")  : mword 8)) then decoded_prefixes
           else reset_prefixes_not_at_end (decoded_prefixes) in
         let rex_contents : REX_typ := next_prefix in
         let new_decoded_prefixes := reset_decoded_prefixes <|decodedPrefixes_REX := rex_contents|> in
         (_rec_decode_prefix_inner (instruction_ptr) ((Z.add (read_offset) (1)))
            (new_decoded_prefixes) (next_prefix) ((Z.sub (max_iters) (1))) ((Z.sub (_reclimit) (1)))
            (_limit_reduces_bool _acc ltac:(assumption)))
          : M ((Z * decodedPrefixes))
       else
         (_rec_decode_prefix_inner (instruction_ptr) (read_offset) (decoded_prefixes) (prev_prefix)
            (0) ((Z.sub (_reclimit) (1))) (_limit_reduces_bool _acc ltac:(assumption)))
          : M ((Z * decodedPrefixes)))
       : M ((Z * decodedPrefixes)))
    : M ((Z * decodedPrefixes))
).
Defined.


Definition decode_prefix_inner
(_arg0 : mword 64) (_arg1 : Z) (_arg2 : decodedPrefixes) (_arg3 : mword 8) (max_iters : Z)
: M ((Z * decodedPrefixes)) :=
   (_rec_decode_prefix_inner (_arg0) (_arg1) (_arg2) (_arg3) (max_iters) ((max_iters  : Z))
      (Zwf_guarded _))
    : M ((Z * decodedPrefixes)).

Definition decode_prefix (instruction_ptr : mword 64) (decoded_prefixes : decodedPrefixes)
: M ((Z * decodedPrefixes)) :=
   decode_prefix_inner (instruction_ptr) (0) (decoded_prefixes) (((Ox"00")  : mword 8)) (15).

Definition get_mod_rm_byte_REG (mod_rm_byte : mword 8) (REX : mword 8) : Z :=
   let base_reg_loc := uint ((_get_modRMByte_REG (mod_rm_byte))) in
   if eq_vec ((_get_REX_R (REX))) ((('b"1")  : mword 1)) then Z.add (8) (base_reg_loc)
   else base_reg_loc.

Definition get_mod_rm_byte_RM (mod_rm_byte : mword 8) (REX : mword 8) : Z :=
   let base_reg_loc := uint ((_get_modRMByte_RM (mod_rm_byte))) in
   if eq_vec ((_get_REX_B (REX))) ((('b"1")  : mword 1)) then Z.add (8) (base_reg_loc)
   else base_reg_loc.

Definition get_sib_byte_BASE (sib_byte : mword 8) (REX : mword 8) : Z :=
   let base_reg_loc := uint ((_get_SIBByte_Base (sib_byte))) in
   if eq_vec ((_get_REX_B (REX))) ((('b"1")  : mword 1)) then Z.add (8) (base_reg_loc)
   else base_reg_loc.

Definition get_sib_byte_INDEX (sib_byte : mword 8) (REX : mword 8) : Z :=
   let base_reg_loc := uint ((_get_SIBByte_Index (sib_byte))) in
   if eq_vec ((_get_REX_X (REX))) ((('b"1")  : mword 1)) then Z.add (8) (base_reg_loc)
   else base_reg_loc.

Definition get_reg_value_in_opcode_byte (reg_field : mword 3) (REX : mword 8) : Z :=
   let base_reg_loc := uint (reg_field) in
   if eq_vec ((_get_REX_B (REX))) ((('b"1")  : mword 1)) then Z.add (8) (base_reg_loc)
   else base_reg_loc.

Definition decode_sib_byte (sib_byte : mword 8) (REX : mword 8) : M (mword 64) :=
   let sib_byte_BASE := get_sib_byte_BASE (sib_byte) (REX) in
   let sib_byte_INDEX := get_sib_byte_INDEX (sib_byte) (REX) in
   (if Z.eqb (sib_byte_BASE) (5) then returnM ((zero_extend (((Ox"0")  : mword 4)) (64)))
    else (read_GPR (64) ((REG_NORMAL (sib_byte_BASE))))  : M (mword 64)) >>= fun base =>
   (if Z.eqb (sib_byte_INDEX) (4) then returnM ((zero_extend (((Ox"0")  : mword 4)) (64)))
    else (read_GPR (64) ((REG_NORMAL (sib_byte_INDEX))))  : M (mword 64)) >>= fun index =>
   returnM ((add_vec (base) ((shiftl (index) ((uint ((_get_SIBByte_Scale (sib_byte))))))))).

Definition read_mod_rm_byte (instruction_ptr : mword 64) (read_offset : Z) : M ((Z * mword 8)) :=
   (read_memory (1) ((add_vec_int (instruction_ptr) (read_offset)))
      ((create_iFetchAccessDescriptor (tt)))) >>= fun mod_rm_byte_contents =>
   returnM ((Z.add (read_offset) (1), mod_rm_byte_contents)).

Definition get_operand_size_using_REX
(decoded_prefixes : decodedPrefixes) (default_operand_size : Z)
(*member_Z_list default_operand_size [32; 64]*)
: Z :=
   if eq_vec ((_get_REX_W (decoded_prefixes.(decodedPrefixes_REX)))) ((('b"1")  : mword 1)) then 64
   else if decoded_prefixes.(decodedPrefixes_op_size_override) then 16
   else default_operand_size.

Definition get_operand_size_ignoring_REX
(decoded_prefixes : decodedPrefixes) (default_operand_size : Z)
(*member_Z_list default_operand_size [32; 64]*)
: Z :=
   if decoded_prefixes.(decodedPrefixes_op_size_override) then 16 else default_operand_size.

Definition read_imm_operand (instruction_ptr : mword 64) (read_offset : Z) (operand_size : Z)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M ((Z * imm)) :=
   let operand_size_bytes := Z.quot (operand_size) (8) in
   assert_exp' (Z.eqb (operand_size) ((Z.mul (8) (operand_size_bytes)))) "decode.sail:220.49-220.50" >>= fun _ =>
   (read_memory (operand_size_bytes) ((add_vec_int (instruction_ptr) (read_offset)))
      ((create_iFetchAccessDescriptor (tt)))) >>= fun imm_value =>
   let l__0 := operand_size in
   let wrapped_imm : imm :=
     if Z.eqb (l__0) (8) then IMM8 ((autocast (T := mword)  imm_value))
     else if Z.eqb (l__0) (16) then IMM16 ((autocast (T := mword)  imm_value))
     else if Z.eqb (l__0) (32) then IMM32 ((autocast (T := mword)  imm_value))
     else IMM64 ((autocast (T := mword)  imm_value)) in
   returnM ((Z.add (read_offset) (operand_size_bytes), wrapped_imm)).

Definition wrap_reg (reg_index : Z) (operand_size : Z) (REX : mword 8)
(*(0 <=? reg_index) && (reg_index <=? 15)*) (*member_Z_list operand_size [8; 16; 32; 64]*)
: reg :=
   if andb ((Z.eqb (operand_size) (8)))
        ((andb ((eq_vec (REX) (((Ox"00")  : mword 8))))
            ((andb ((Z.geb (reg_index) (4))) ((Z.leb (reg_index) (7))))))) then
     REG_HIGH_BYTE ((Z.sub (reg_index) (4)))
   else REG_NORMAL (reg_index).

Definition decode_rm_operand_inner
(arg0 : addressingMethod) (arg1 : mword 64) (arg2 : Z) (arg3 : mword 8) (arg4 : Z) (arg5 : mword 8)
(*member_Z_list arg4 [8; 16; 32; 64]*)
: M ((Z * rm_operand)) :=
   let merge_var := (arg0, arg1, arg2, arg3, arg4, arg5) in
   match merge_var with
   | (addressingMethod_E, instruction_ptr, read_offset, mod_rm_byte, operand_size, REX) =>
      let reg_used : reg_index := get_mod_rm_byte_RM (mod_rm_byte) (REX) in
      (if eq_vec ((_get_modRMByte_Mod (mod_rm_byte))) ((('b"11")  : mword 2)) then
         let wrapped_reg := wrap_reg (reg_used) (operand_size) (REX) in
         returnM ((read_offset, rm_REG (wrapped_reg)))
       else
         let new_read_offset : Z := read_offset in
         let three_bit_reg_used := mod' (reg_used) (8) in
         (if Z.eqb (three_bit_reg_used) (4) return M ((mword 64 * Z)) then
            (read_memory (1) ((add_vec_int (instruction_ptr) (new_read_offset)))
               ((create_iFetchAccessDescriptor (tt)))) >>= fun (sib_byte : SIBByte) =>
            (decode_sib_byte (sib_byte) (REX)) >>= fun sib_value =>
            let new_read_offset : Z := Z.add (new_read_offset) (1) in
            returnM ((sib_value, new_read_offset))
          else
            (read_GPR (64) ((REG_NORMAL (reg_used)))) >>= fun (w__0 : mword 64) =>
            returnM ((w__0, new_read_offset))) >>= fun '((mem_loc, new_read_offset)
         : (mword 64 * Z)) =>
         let b__0 := _get_modRMByte_Mod (mod_rm_byte) in
         (if eq_vec (b__0) ((('b"01")  : mword 2)) return M ((mword 64 * Z)) then
            (read_memory (1) ((add_vec_int (instruction_ptr) (new_read_offset)))
               ((create_iFetchAccessDescriptor (tt)))) >>= fun displacement =>
            let mem_loc : bits 64 := add_vec (mem_loc) ((sign_extend (displacement) (64))) in
            let new_read_offset : Z := Z.add (new_read_offset) (1) in
            returnM ((mem_loc, new_read_offset))
          else if eq_vec (b__0) ((('b"10")  : mword 2)) return M ((mword 64 * Z)) then
            (read_memory (4) ((add_vec_int (instruction_ptr) (new_read_offset)))
               ((create_iFetchAccessDescriptor (tt)))) >>= fun displacement =>
            let mem_loc : bits 64 := add_vec (mem_loc) ((sign_extend (displacement) (64))) in
            let new_read_offset : Z := Z.add (new_read_offset) (4) in
            returnM ((mem_loc, new_read_offset))
          else returnM ((mem_loc, new_read_offset))) >>= fun '((mem_loc, new_read_offset)
         : (mword 64 * Z)) =>
         returnM ((new_read_offset, rm_MEM (mem_loc))))
       : M ((Z * rm_operand))
   | (addressingMethod_G, instruction_ptr, read_offset, mod_rm_byte, operand_size, REX) =>
      let reg_index := get_mod_rm_byte_REG (mod_rm_byte) (REX) in
      let wrapped_reg := wrap_reg (reg_index) (operand_size) (REX) in
      returnM ((read_offset, rm_REG (wrapped_reg)))
   end
    : M ((Z * rm_operand)).

Definition decode_2_rm_operands
(instruction_ptr : mword 64) (read_offset : Z) (operand1_addr_method : addressingMethod)
(operand2_addr_method : addressingMethod) (operand_size : Z) (REX : mword 8)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M ((Z * rm_operand * rmi_operand)) :=
   (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((new_offset, mod_rm_byte)) =>
   (decode_rm_operand_inner (operand1_addr_method) (instruction_ptr) (new_offset) (mod_rm_byte)
      (operand_size) (REX)) >>= fun '((new_offset2, operand1)) =>
   (decode_rm_operand_inner (operand2_addr_method) (instruction_ptr) (new_offset2) (mod_rm_byte)
      (operand_size) (REX)) >>= fun '((new_offset3, working_operand2)) =>
   let operand2 : rmi_operand :=
     match working_operand2 with
     | rm_REG value => rmi_REG (value)
     | rm_MEM value => rmi_MEM (value)
     end in
   returnM ((new_offset3, operand1, operand2)).

Definition get_Ev_Gv_operands
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
: M ((Z * Z * rm_operand * rmi_operand)) :=
   let operand_size := get_operand_size_using_REX (decoded_prefixes) (32) in
   (decode_2_rm_operands (instruction_ptr) (read_offset) (addressingMethod_E) (addressingMethod_G)
      (operand_size) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
   returnM ((new_read_offset, operand_size, operand1, operand2)).

Definition get_Gv_Ev_operands
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
: M ((Z * Z * rm_operand * rmi_operand)) :=
   let operand_size := get_operand_size_using_REX (decoded_prefixes) (32) in
   (decode_2_rm_operands (instruction_ptr) (read_offset) (addressingMethod_G) (addressingMethod_E)
      (operand_size) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
   returnM ((new_read_offset, operand_size, operand1, operand2)).

Definition get_Eb_Gb_operands (instruction_ptr : mword 64) (read_offset : Z) (REX : mword 8)
: M ((Z * rm_operand * rmi_operand)) :=
   (decode_2_rm_operands (instruction_ptr) (read_offset) (addressingMethod_E) (addressingMethod_G)
      (8) (REX))
    : M ((Z * rm_operand * rmi_operand)).

Definition get_Gb_Eb_operands (instruction_ptr : mword 64) (read_offset : Z) (REX : mword 8)
: M ((Z * rm_operand * rmi_operand)) :=
   (decode_2_rm_operands (instruction_ptr) (read_offset) (addressingMethod_G) (addressingMethod_E)
      (8) (REX))
    : M ((Z * rm_operand * rmi_operand)).

Definition decode_push_or_pop_rm_operand
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
(mod_rm_byte : mword 8)
: M ((Z * Z * rm_operand)) :=
   let operand_size := get_operand_size_ignoring_REX (decoded_prefixes) (64) in
   (decode_rm_operand_inner (addressingMethod_E) (instruction_ptr) (read_offset) (mod_rm_byte)
      (operand_size) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((final_offset, operand)) =>
   returnM ((final_offset, operand_size, operand)).

Definition get_Ev_Iz_operands
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
(mod_rm_byte : mword 8)
: M ((Z * Z * rm_operand * imm)) :=
   let operand_size := get_operand_size_using_REX (decoded_prefixes) (32) in
   (decode_rm_operand_inner (addressingMethod_E) (instruction_ptr) (read_offset) (mod_rm_byte)
      (operand_size) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((read_offset, operand1)) =>
   let imm_size := if Z.eqb (operand_size) (64) then 32 else operand_size in
   (read_imm_operand (instruction_ptr) (read_offset) (imm_size)) >>= fun '((read_offset, imm)) =>
   returnM ((read_offset, operand_size, operand1, imm)).

Definition get_Eb_Ib_operands
(instruction_ptr : mword 64) (read_offset : Z) (REX : mword 8) (mod_rm_byte : mword 8)
: M ((Z * rm_operand * imm)) :=
   (decode_rm_operand_inner (addressingMethod_E) (instruction_ptr) (read_offset) (mod_rm_byte) (8)
      (REX)) >>= fun '((read_offset, operand1)) =>
   (read_imm_operand (instruction_ptr) (read_offset) (8)) >>= fun '((read_offset, imm)) =>
   returnM ((read_offset, operand1, imm)).

Definition fail_if_lock (lock : bool) (operation : string) : M (unit) :=
   let error_message :=
     String.append ("Exception #UD â€” Invalid Opcode (Undefined Opcode): ")
       ((String.append (operation) (" instruction does not support the LOCK prefix"))) in
   (if lock return M (unit) then (fail (error_message))  : M (unit)
    else returnM (tt))
    : M (unit).

Definition decode_one_byte_instruction
(b__0 : mword 8) (instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
: M (option ((Z * ast))) :=
   (if eq_vec (b__0) (((Ox"88")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      (get_Eb_Gb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, MOV ((8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"89")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      (get_Ev_Gv_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, MOV ((operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"8A")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      (get_Gb_Eb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, MOV ((8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"8B")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, MOV ((operand_size, operand1, operand2))))))
    else if eq_vec ((subrange_vec_dec (b__0) (7) (4))) (((Ox"B")  : mword 4))
      return
      M (option ((Z * ast))) then
      let reg_field := subrange_vec_dec (b__0) (2) (0) in
      let not_8_bit : bits 1 := subrange_vec_dec (b__0) (3) (3) in
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      let reg_index :=
        get_reg_value_in_opcode_byte (reg_field) (decoded_prefixes.(decodedPrefixes_REX)) in
      let reg :=
        if eq_vec (not_8_bit) ((('b"1")  : mword 1)) then REG_NORMAL (reg_index)
        else wrap_reg (reg_index) (8) (decoded_prefixes.(decodedPrefixes_REX)) in
      let operand_size :=
        if eq_vec (not_8_bit) ((('b"1")  : mword 1)) then
          get_operand_size_using_REX (decoded_prefixes) (32)
        else 8 in
      (read_imm_operand (instruction_ptr) (read_offset) (operand_size)) >>= fun '((new_read_offset, imm)) =>
      returnM ((Some ((new_read_offset, MOV ((operand_size, rm_REG (reg), rmi_IMM (imm)))))))
    else if eq_vec ((subrange_vec_dec (b__0) (7) (1))) ((('b"1100110")  : mword 7))
      return
      M (option ((Z * ast))) then
      let not_8_bit := subrange_vec_dec (b__0) (0) (0) in
      (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((read_offset_2, mod_rm_byte)) =>
      (if neq_int ((uint ((_get_modRMByte_REG (mod_rm_byte))))) (0) return M (unit) then
         (fail ("The instruction to be decoded is either reserved or not implemented in this model"))
          : M (unit)
       else returnM (tt)) >>
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("MOV")) >>
      (if eq_vec (not_8_bit) ((('b"1")  : mword 1)) return M ((Z * Z * rm_operand * imm)) then
         (get_Ev_Iz_operands (instruction_ptr) (read_offset) (decoded_prefixes) (mod_rm_byte))
          : M ((Z * Z * rm_operand * imm))
       else
         (get_Eb_Ib_operands (instruction_ptr) (read_offset)
            (decoded_prefixes.(decodedPrefixes_REX)) (mod_rm_byte)) >>= fun '((new_read_offset, operand1, imm)) =>
         returnM ((new_read_offset, 8, operand1, imm))) >>= fun '((new_read_offset, operand_size, operand1, imm)) =>
      returnM ((Some ((new_read_offset, MOV ((operand_size, operand1, rmi_IMM (imm)))))))
    else if eq_vec (b__0) (((Ox"30")  : mword 8)) return M (option ((Z * ast))) then
      (get_Eb_Gb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, XOR
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"31")  : mword 8)) return M (option ((Z * ast))) then
      (get_Ev_Gv_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, XOR
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"32")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gb_Eb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, XOR
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"33")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, XOR
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec ((subrange_vec_dec (b__0) (7) (1))) ((('b"1000000")  : mword 7))
      return
      M (option ((Z * ast))) then
      let not_8_bit := subrange_vec_dec (b__0) (0) (0) in
      (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((read_offset, mod_rm_byte)) =>
      (if eq_vec (not_8_bit) ((('b"1")  : mword 1)) return M ((Z * Z * rm_operand * imm)) then
         (get_Ev_Iz_operands (instruction_ptr) (read_offset) (decoded_prefixes) (mod_rm_byte))
          : M ((Z * Z * rm_operand * imm))
       else
         (get_Eb_Ib_operands (instruction_ptr) (read_offset)
            (decoded_prefixes.(decodedPrefixes_REX)) (mod_rm_byte)) >>= fun '((new_read_offset, operand1, imm)) =>
         returnM ((new_read_offset, 8, operand1, imm))) >>= fun '((new_read_offset, operand_size, operand1, imm)) =>
      let l__0 := uint ((_get_modRMByte_REG (mod_rm_byte))) in
      (if Z.eqb (l__0) (0) then
         returnM ((Some
                     ((new_read_offset, ADD
                                          ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, rmi_IMM
                                                                                                               (imm)))))))
       else if Z.eqb (l__0) (5) then
         returnM ((Some
                     ((new_read_offset, SUB
                                          ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, rmi_IMM
                                                                                                               (imm)))))))
       else if Z.eqb (l__0) (6) then
         returnM ((Some
                     ((new_read_offset, XOR
                                          ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, rmi_IMM
                                                                                                               (imm)))))))
       else if Z.eqb (l__0) (7) return M (option ((Z * ast))) then
         (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CMP")) >>
         returnM ((Some ((new_read_offset, CMP ((operand_size, operand1, rmi_IMM (imm)))))))
       else
         (fail ("The instruction to be decoded is not implemented in this model"))
          : M (option ((Z * ast))))
       : M (option ((Z * ast)))
    else if eq_vec (b__0) (((Ox"38")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CMP")) >>
      (get_Eb_Gb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, CMP ((8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"39")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CMP")) >>
      (get_Ev_Gv_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, CMP ((operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"3A")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CMP")) >>
      (get_Gb_Eb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, CMP ((8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"3B")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CMP")) >>
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some ((new_read_offset, CMP ((operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"6A")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("PUSH")) >>
      (read_imm_operand (instruction_ptr) (read_offset) (8)) >>= fun '((new_read_offset, imm)) =>
      returnM ((Some ((new_read_offset, PUSH ((8, rmi_IMM (imm)))))))
    else if eq_vec (b__0) (((Ox"68")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("PUSH")) >>
      let operand_size := get_operand_size_ignoring_REX (decoded_prefixes) (32) in
      (read_imm_operand (instruction_ptr) (read_offset) (operand_size)) >>= fun '((new_read_offset, imm)) =>
      returnM ((Some ((new_read_offset, PUSH ((operand_size, rmi_IMM (imm)))))))
    else if eq_vec (b__0) (((Ox"FF")  : mword 8)) return M (option ((Z * ast))) then
      (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((new_read_offset, mod_rm_byte)) =>
      (if neq_int ((uint ((_get_modRMByte_REG (mod_rm_byte))))) (6) return M (unit) then
         (fail ("The instruction to be decoded is either reserved or not implemented in this model"))
          : M (unit)
       else returnM (tt)) >>
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("PUSH")) >>
      (decode_push_or_pop_rm_operand (instruction_ptr) (new_read_offset) (decoded_prefixes)
         (mod_rm_byte)) >>= fun '((final_read_offset, operand_size, working_operand)) =>
      let operand : rmi_operand :=
        match working_operand with
        | rm_REG contents => rmi_REG (contents)
        | rm_MEM contents => rmi_MEM (contents)
        end in
      returnM ((Some ((final_read_offset, PUSH ((operand_size, operand))))))
    else if eq_vec ((subrange_vec_dec (b__0) (7) (4))) (((Ox"5")  : mword 4))
      return
      M (option ((Z * ast))) then
      let reg_field : bits 3 := subrange_vec_dec (b__0) (2) (0) in
      let is_pop : bits 1 := subrange_vec_dec (b__0) (3) (3) in
      let reg_index :=
        get_reg_value_in_opcode_byte (reg_field) (decoded_prefixes.(decodedPrefixes_REX)) in
      let reg := REG_NORMAL (reg_index) in
      let operand_size := get_operand_size_ignoring_REX (decoded_prefixes) (64) in
      (if eq_vec (is_pop) ((('b"0")  : mword 1)) return M (option ((Z * ast))) then
         (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("PUSH")) >>
         returnM ((Some ((read_offset, PUSH ((operand_size, rmi_REG (reg)))))))
       else
         (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("POP")) >>
         returnM ((Some ((read_offset, POP ((operand_size, rm_REG (reg))))))))
       : M (option ((Z * ast)))
    else if eq_vec (b__0) (((Ox"8F")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("POP")) >>
      (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((new_read_offset, mod_rm_byte)) =>
      (if neq_int ((uint ((_get_modRMByte_REG (mod_rm_byte))))) (0) return M (unit) then
         (fail ("The instruction to be decoded is reserved"))
          : M (unit)
       else returnM (tt)) >>
      (decode_push_or_pop_rm_operand (instruction_ptr) (new_read_offset) (decoded_prefixes)
         (mod_rm_byte)) >>= fun '((final_read_offset, operand_size, operand)) =>
      returnM ((Some ((final_read_offset, POP ((operand_size, operand))))))
    else if eq_vec (b__0) (((Ox"00")  : mword 8)) return M (option ((Z * ast))) then
      (get_Eb_Gb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, ADD
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"01")  : mword 8)) return M (option ((Z * ast))) then
      (get_Ev_Gv_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, ADD
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"02")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gb_Eb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, ADD
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"03")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, ADD
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"28")  : mword 8)) return M (option ((Z * ast))) then
      (get_Eb_Gb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, SUB
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"29")  : mword 8)) return M (option ((Z * ast))) then
      (get_Ev_Gv_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, SUB
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"2A")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gb_Eb_operands (instruction_ptr) (read_offset) (decoded_prefixes.(decodedPrefixes_REX))) >>= fun '((new_read_offset, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, SUB
                                       ((decoded_prefixes.(decodedPrefixes_lock), 8, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"2B")  : mword 8)) return M (option ((Z * ast))) then
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, operand1, operand2)) =>
      returnM ((Some
                  ((new_read_offset, SUB
                                       ((decoded_prefixes.(decodedPrefixes_lock), operand_size, operand1, operand2))))))
    else if eq_vec (b__0) (((Ox"E8")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("CALL")) >>
      (if decoded_prefixes.(decodedPrefixes_op_size_override) return M (unit) then
         (fail ("CALL rel16 is not supported in 64-bit mode"))
          : M (unit)
       else returnM (tt)) >>
      (read_memory (4) ((add_vec_int (instruction_ptr) (read_offset)))
         ((create_iFetchAccessDescriptor (tt)))) >>= fun operand =>
      let new_read_offset := Z.add (read_offset) (4) in
      returnM ((Some ((new_read_offset, CALL (operand)))))
    else if eq_vec (b__0) (((Ox"C9")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("LEAVE")) >>
      let operand_size := get_operand_size_ignoring_REX (decoded_prefixes) (64) in
      assert_exp' (orb ((Z.eqb (operand_size) (16))) ((Z.eqb (operand_size) (64)))) "tiny-x86.sail:757.50-757.51" >>= fun _ =>
      returnM ((Some ((read_offset, LEAVE (operand_size)))))
    else if eq_vec (b__0) (((Ox"C3")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("RET")) >>
      returnM ((Some ((read_offset, RET (tt)))))
    else if eq_vec (b__0) (((Ox"EB")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("JMP")) >>
      (read_memory (1) ((add_vec_int (instruction_ptr) (read_offset)))
         ((create_iFetchAccessDescriptor (tt)))) >>= fun operand =>
      let new_read_offset := Z.add (read_offset) (1) in
      returnM ((Some ((new_read_offset, JMP (operand)))))
    else if eq_vec (b__0) (((Ox"79")  : mword 8)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("JNS")) >>
      (read_memory (1) ((add_vec_int (instruction_ptr) (read_offset)))
         ((create_iFetchAccessDescriptor (tt)))) >>= fun operand =>
      let new_read_offset := Z.add (read_offset) (1) in
      returnM ((Some ((new_read_offset, JNS (operand)))))
    else returnM (None))
    : M (option ((Z * ast))).

Definition decode_two_byte_instruction
(b__0 : mword 16) (instruction_ptr : mword 64) (read_offset : Z)
(decoded_prefixes : decodedPrefixes)
: M (option ((Z * ast))) :=
   (if eq_vec (b__0) (((Ox"0FAE")  : mword 16)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("FENCE")) >>
      (read_mod_rm_byte (instruction_ptr) (read_offset)) >>= fun '((new_read_offset, mod_rm_byte)) =>
      (if eq_vec ((_get_modRMByte_Mod (mod_rm_byte))) ((('b"11")  : mword 2))
         return
         M (option ((Z * ast))) then
         let b__1 := _get_modRMByte_REG (mod_rm_byte) in
         (if eq_vec (b__1) ((('b"111")  : mword 3)) return M (option ((Z * ast))) then
            (if decoded_prefixes.(decodedPrefixes_op_size_override)
               return
               M (option ((Z * ast))) then
               (fail ("Prefix 66H is not allowed in the SFENCE instruction"))
                : M (option ((Z * ast)))
             else returnM ((Some ((new_read_offset, SFENCE (tt))))))
             : M (option ((Z * ast)))
          else if eq_vec (b__1) ((('b"101")  : mword 3)) return M (option ((Z * ast))) then
            (if decoded_prefixes.(decodedPrefixes_op_size_override)
               return
               M (option ((Z * ast))) then
               (fail ("Prefix 66H is not allowed in the LFENCE instruction"))
                : M (option ((Z * ast)))
             else returnM ((Some ((new_read_offset, LFENCE (tt))))))
             : M (option ((Z * ast)))
          else if eq_vec (b__1) ((('b"110")  : mword 3)) return M (option ((Z * ast))) then
            (if decoded_prefixes.(decodedPrefixes_op_size_override)
               return
               M (option ((Z * ast))) then
               (fail ("Prefix 66H is not allowed in the MFENCE instruction"))
                : M (option ((Z * ast)))
             else returnM ((Some ((new_read_offset, MFENCE (tt))))))
             : M (option ((Z * ast)))
          else
            (fail ("This instruction decode is either reserved or not implemented in this model"))
             : M (option ((Z * ast))))
          : M (option ((Z * ast)))
       else
         (fail ("This instruction decode is not implemented in this model"))
          : M (option ((Z * ast))))
       : M (option ((Z * ast)))
    else if eq_vec (b__0) (((Ox"0FAF")  : mword 16)) return M (option ((Z * ast))) then
      (fail_if_lock (decoded_prefixes.(decodedPrefixes_lock)) ("IMUL")) >>
      (get_Gv_Ev_operands (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun '((new_read_offset, operand_size, rm_operand1, rmi_operand2)) =>
      match (rm_operand1, rmi_operand2) with
      | (rm_REG (REG_NORMAL reg_index_1), rmi_REG reg_2) =>
         returnM ((Some ((new_read_offset, IMUL ((operand_size, reg_index_1, rm_REG (reg_2)))))))
      | (rm_REG (REG_NORMAL reg_index), rmi_MEM mem_loc) =>
         returnM ((Some ((new_read_offset, IMUL ((operand_size, reg_index, rm_MEM (mem_loc)))))))
      | _ => (fail ("Invalid decoding for IMUL r r/m instruction"))  : M (option ((Z * ast)))
      end
       : M (option ((Z * ast)))
    else returnM (None))
    : M (option ((Z * ast))).

Definition decode_instruction
(instruction_ptr : mword 64) (read_offset : Z) (decoded_prefixes : decodedPrefixes)
: M (option ((Z * ast))) :=
   (read_memory (1) ((add_vec_int (instruction_ptr) (read_offset)))
      ((create_iFetchAccessDescriptor (tt)))) >>= fun one_byte_opcode =>
   let new_read_offset : Z := Z.add (read_offset) (1) in
   (decode_one_byte_instruction (one_byte_opcode) (instruction_ptr) (new_read_offset)
      (decoded_prefixes)) >>= fun res =>
   (if generic_eq (res) (None) return M (option ((Z * ast))) then
      (read_memory (1) ((add_vec_int (instruction_ptr) (new_read_offset)))
         ((create_iFetchAccessDescriptor (tt)))) >>= fun (w__0 : mword (8 * 1)) =>
      let two_byte_opcode := concat_vec (one_byte_opcode) (w__0) in
      let new_read_offset : Z := Z.add (new_read_offset) (1) in
      (decode_two_byte_instruction (two_byte_opcode) (instruction_ptr) (new_read_offset)
         (decoded_prefixes))
       : M (option ((Z * ast)))
    else returnM (res))
    : M (option ((Z * ast))).

Definition decode (instruction_ptr : mword 64) : M (option ((mword 64 * ast))) :=
   let read_offset : Z := 0 in
   let decoded_prefixes : decodedPrefixes :=
     {| decodedPrefixes_lock := false;
        decodedPrefixes_op_size_override := false;
        decodedPrefixes_mandatory_prefix_66H := false;
        decodedPrefixes_REX := (Ox"00")  : mword 8 |} in
   (decode_prefix (instruction_ptr) (decoded_prefixes)) >>= fun (w__0 : (Z * decodedPrefixes)) =>
   let '((tup__0, tup__1)) := w__0  : (Z * decodedPrefixes) in
   let read_offset : Z := tup__0 in
   let decoded_prefixes : decodedPrefixes := tup__1 in
   (decode_instruction (instruction_ptr) (read_offset) (decoded_prefixes)) >>= fun res =>
   match res with
   | None => returnM (None)
   | Some (offset, instruction) =>
      (if Z.gtb (offset) (15) return M (option ((mword 64 * ast))) then
         (fail ("Instruction is longer than 15 bytes, hence is not valid"))
          : M (option ((mword 64 * ast)))
       else returnM ((Some ((add_vec_int (instruction_ptr) (offset), instruction)))))
       : M (option ((mword 64 * ast)))
   end
    : M (option ((mword 64 * ast))).

Definition fail_if_two_mem_operands (dest : rm_operand) (src : rmi_operand) (operation : string)
: M (unit) :=
   let error_message :=
     String.append (operation) (" operation cannot occur between 2 memory locations") in
   match (dest, src) with
   | (rm_MEM _, rmi_MEM _) => (fail (error_message))  : M (unit)
   | (_, _) => returnM (tt)
   end
    : M (unit).

Definition execute_ADD (lock : bool) (operand_size : Z) (dest : rm_operand) (src : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (fail_if_two_mem_operands (dest) (src) ("ADD")) >>
   match src with
   | rmi_IMM (IMM64 _) =>
      (fail ("For operation ADD, src = imm64 is not a valid operand"))  : M (unit)
   | _ => returnM (tt)
   end >>
   match dest with
   | rm_REG g__4 =>
      (if lock return M (unit) then
         (fail
            ("Exception #UD â€” Invalid Opcode (Undefined Opcode): LOCK prefix cannot be applied to dest = reg"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   | _ => returnM (tt)
   end >>
   (read_rm_operand_with_lock (lock) (operand_size) (dest)) >>= fun dest_val =>
   (read_rmi_operand_with_lock (false) (operand_size) (src)) >>= fun src_val =>
   let result' := add_vec (dest_val) (src_val) in
   (write_rm_operand_with_lock (lock) (operand_size) (dest) (result')) >>
   (update_RFLAGS_add (dest_val) (src_val) (result'))
    : M (unit).

Definition execute_CALL (rel32 : mword 32) : M (unit) :=
   let displacement := sign_extend (rel32) (64) in
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg RSP (sub_vec (w__0) ((zero_extend (((Ox"8")  : mword 4)) (64)))) >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
   ((read_reg RIP)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
   (write_rm_operand_without_lock (64) ((rm_MEM (w__1))) (w__2)) >>
   ((read_reg RIP)  : M (mword 64)) >>= fun (w__3 : mword 64) =>
   write_reg RIP (add_vec (w__3) (displacement))
    : M (unit).

Definition execute_CMP (operand_size : Z) (first : rm_operand) (second : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (fail_if_two_mem_operands (first) (second) ("CMP")) >>
   match second with
   | rmi_IMM (IMM64 _) =>
      (fail ("For operation CMP, second = imm64 is not a valid operand"))  : M (unit)
   | _ => returnM (tt)
   end >>
   (read_rm_operand_without_lock (operand_size) (first)) >>= fun first_val =>
   (read_rmi_operand_without_lock (operand_size) (second)) >>= fun second_val =>
   let result' := sub_vec (first_val) (second_val) in
   (update_RFLAGS_sub (first_val) (second_val) (result'))
    : M (unit).

Definition execute_IMUL (operand_size : Z) (dest : Z) (src : rm_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*) (*(0 <=? dest) && (dest <=? 15)*)
: M (unit) :=
   (if Z.eqb (operand_size) (8) return M (unit) then
      (fail ("8 bit operands are not valid for operation IMUL"))
       : M (unit)
    else returnM (tt)) >>
   let wrapped_dest := REG_NORMAL (dest) in
   (read_GPR (operand_size) (wrapped_dest)) >>= fun dest_val =>
   (read_rm_operand_without_lock (operand_size) (src)) >>= fun src_val =>
   let result_int := Z.mul ((sint (dest_val))) ((sint (src_val))) in
   let result_128 := get_slice_int ((Z.mul (operand_size) (2))) (result_int) (0) in
   let result' := subrange_vec_dec (result_128) ((Z.sub (operand_size) (1))) (0) in
   (write_GPR (operand_size) (wrapped_dest) ((autocast (T := mword)  result'))) >>
   (if eq_vec ((sign_extend (result') ((Z.mul (operand_size) (2))))) (result_128)
      return
      M (unit) then
      ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
      write_reg RFLAGS (update_subrange_vec_dec (w__0) (0) (0) ((('b"0")  : mword 1))) >>
      ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
      write_reg RFLAGS (update_subrange_vec_dec (w__1) (11) (11) ((('b"0")  : mword 1)))
       : M (unit)
    else
      ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
      write_reg RFLAGS (update_subrange_vec_dec (w__2) (0) (0) ((('b"1")  : mword 1))) >>
      ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__3 : mword 64) =>
      write_reg RFLAGS (update_subrange_vec_dec (w__3) (11) (11) ((('b"1")  : mword 1)))
       : M (unit))
    : M (unit).

Definition execute_JMP (rel8 : mword 8) : M (unit) :=
   let displacement := sign_extend (rel8) (64) in
   ((read_reg RIP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg RIP (add_vec (w__0) (displacement))
    : M (unit).

Definition execute_JNS (rel8 : mword 8) : M (unit) :=
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if eq_vec ((_get_rflags_SF (w__0))) ((('b"0")  : mword 1)) return M (unit) then
      let displacement := sign_extend (rel8) (64) in
      ((read_reg RIP)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
      write_reg RIP (add_vec (w__1) (displacement))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition execute_LEAVE (operand_size : Z) (*member_Z_list operand_size [16; 64]*) : M (unit) :=
   ((read_reg RBP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg RSP w__0 >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
   (read_rm_operand_without_lock (operand_size) ((rm_MEM (w__1)))) >>= fun popped_value =>
   (write_GPR (operand_size) ((REG_NORMAL (5))) (popped_value)) >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
   write_reg RSP (add_vec_int (w__2) ((Z.quot (operand_size) (8))))
    : M (unit).

Definition execute_LFENCE '(tt : unit) : M (unit) := (sail_barrier (Barrier_LFENCE))  : M (unit).

Definition execute_MFENCE '(tt : unit) : M (unit) := (sail_barrier (Barrier_MFENCE))  : M (unit).

Definition execute_MOV (operand_size : Z) (dest : rm_operand) (src : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (fail_if_two_mem_operands (dest) (src) ("MOV")) >>
   match (dest, src) with
   | (rm_MEM _, rmi_IMM (IMM64 _)) =>
      (fail ("MOV operation cannot be executed on dest = mem64 and src = imm64"))  : M (unit)
   | (_, _) => returnM (tt)
   end >>
   (read_rmi_operand_without_lock (operand_size) (src)) >>= fun val_to_write =>
   (write_rm_operand_without_lock (operand_size) (dest) (val_to_write))
    : M (unit).

Definition execute_POP (operand_size : Z) (dest : rm_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (if orb ((Z.eqb (operand_size) (8))) ((Z.eqb (operand_size) (32))) return M (unit) then
      (fail ("dest size for POP operation not supported"))
       : M (unit)
    else returnM (tt)) >>
   (if Z.eqb (operand_size) (16) return M (unit) then
      (fail ("dest size for POP operation not implemented in this model"))
       : M (unit)
    else returnM (tt)) >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (read_rm_operand_without_lock (64) ((rm_MEM (w__0)))) >>= fun popped_val =>
   (write_rm_operand_without_lock (64) (dest) (popped_val)) >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
   write_reg RSP (add_vec_int (w__1) (8))
    : M (unit).

Definition execute_PUSH (operand_size : Z) (src : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   match src with
   | rmi_IMM g__1 =>
      (if Z.eqb (operand_size) (64) return M (unit) then
         (fail ("Operand for PUSH operation not allowed"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   | rmi_REG g__2 =>
      (if orb ((Z.eqb (operand_size) (8))) ((Z.eqb (operand_size) (32))) return M (unit) then
         (fail ("Operand for PUSH operation not allowed"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   | rmi_MEM g__3 =>
      (if orb ((Z.eqb (operand_size) (8))) ((Z.eqb (operand_size) (32))) return M (unit) then
         (fail ("Operand for PUSH operation not allowed"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   end >>
   (read_rmi_operand_without_lock (operand_size) (src)) >>= fun w__0 =>
   let src_val := sign_extend (w__0) (64) in
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
   write_reg RSP (sub_vec (w__1) ((zero_extend (((Ox"8")  : mword 4)) (64)))) >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
   let dest_address := rm_MEM (w__2) in
   (write_rm_operand_without_lock (64) (dest_address) (src_val))
    : M (unit).

Definition execute_RET '(tt : unit) : M (unit) :=
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (read_rm_operand_without_lock (64) ((rm_MEM (w__0)))) >>= fun (w__1 : mword 64) =>
   write_reg RIP w__1 >>
   ((read_reg RSP)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
   write_reg RSP (add_vec_int (w__2) (8))
    : M (unit).

Definition execute_SFENCE '(tt : unit) : M (unit) := (sail_barrier (Barrier_SFENCE))  : M (unit).

Definition execute_SUB (lock : bool) (operand_size : Z) (dest : rm_operand) (src : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (fail_if_two_mem_operands (dest) (src) ("SUB")) >>
   match src with
   | rmi_IMM (IMM64 _) =>
      (fail ("For operation SUB, src = imm64 is not a valid operand"))  : M (unit)
   | _ => returnM (tt)
   end >>
   match dest with
   | rm_REG g__5 =>
      (if lock return M (unit) then
         (fail
            ("Exception #UD â€” Invalid Opcode (Undefined Opcode): LOCK prefix cannot be applied to dest = reg"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   | _ => returnM (tt)
   end >>
   (read_rm_operand_with_lock (lock) (operand_size) (dest)) >>= fun dest_val =>
   (read_rmi_operand_with_lock (false) (operand_size) (src)) >>= fun src_val =>
   let result' := sub_vec (dest_val) (src_val) in
   (write_rm_operand_with_lock (lock) (operand_size) (dest) (result')) >>
   (update_RFLAGS_sub (dest_val) (src_val) (result'))
    : M (unit).

Definition execute_XOR (lock : bool) (operand_size : Z) (dest : rm_operand) (src : rmi_operand)
(*member_Z_list operand_size [8; 16; 32; 64]*)
: M (unit) :=
   (fail_if_two_mem_operands (dest) (src) ("XOR")) >>
   match src with
   | rmi_IMM (IMM64 _) =>
      (fail ("For operation XOR, src = imm64 is not a valid operand"))  : M (unit)
   | _ => returnM (tt)
   end >>
   match dest with
   | rm_REG g__0 =>
      (if lock return M (unit) then
         (fail
            ("Exception #UD â€” Invalid Opcode (Undefined Opcode): LOCK prefix cannot be applied to dest = reg"))
          : M (unit)
       else returnM (tt))
       : M (unit)
   | _ => returnM (tt)
   end >>
   (read_rm_operand_with_lock (lock) (operand_size) (dest)) >>= fun dest_val =>
   (read_rmi_operand_with_lock (false) (operand_size) (src)) >>= fun src_val =>
   let result' := xor_vec (dest_val) (src_val) in
   (write_rm_operand_with_lock (lock) (operand_size) (dest) (result')) >>
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg RFLAGS (update_subrange_vec_dec (w__0) (11) (11) ((('b"0")  : mword 1))) >>
   ((read_reg RFLAGS)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
   write_reg RFLAGS (update_subrange_vec_dec (w__1) (0) (0) ((('b"0")  : mword 1))) >>
   (update_sign_flag ((length_mword (src_val))) (result')) >>
   (update_zero_flag ((length_mword (src_val))) (result')) >>
   (update_parity_flag (result'))
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   match merge_var with
   | MOV (operand_size, dest, src) => (execute_MOV (operand_size) (dest) (src))  : M (unit)
   | XOR (lock, operand_size, dest, src) =>
      (execute_XOR (lock) (operand_size) (dest) (src))  : M (unit)
   | SFENCE arg0 => (execute_SFENCE (arg0))  : M (unit)
   | LFENCE arg0 => (execute_LFENCE (arg0))  : M (unit)
   | MFENCE arg0 => (execute_MFENCE (arg0))  : M (unit)
   | CMP (operand_size, first, second) => (execute_CMP (operand_size) (first) (second))  : M (unit)
   | PUSH (operand_size, src) => (execute_PUSH (operand_size) (src))  : M (unit)
   | POP (operand_size, dest) => (execute_POP (operand_size) (dest))  : M (unit)
   | ADD (lock, operand_size, dest, src) =>
      (execute_ADD (lock) (operand_size) (dest) (src))  : M (unit)
   | SUB (lock, operand_size, dest, src) =>
      (execute_SUB (lock) (operand_size) (dest) (src))  : M (unit)
   | IMUL (operand_size, dest, src) => (execute_IMUL (operand_size) (dest) (src))  : M (unit)
   | CALL rel32 => (execute_CALL (rel32))  : M (unit)
   | LEAVE operand_size => (execute_LEAVE (operand_size))  : M (unit)
   | RET arg0 => (execute_RET (arg0))  : M (unit)
   | JMP rel8 => (execute_JMP (rel8))  : M (unit)
   | JNS rel8 => (execute_JNS (rel8))  : M (unit)
   end
    : M (unit).

Definition fetch_execute '(tt : unit) : M (unit) :=
   ((read_reg RIP)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (decode (w__0)) >>= fun decoded =>
   match decoded with
   | Some (new_RIP, instr) => write_reg RIP new_RIP >> (execute (instr))  : M (unit)
   | None =>
      (fail ("Instruction is either not implemented in this model, reserved, or malformed."))
       : M (unit)
   end
    : M (unit).

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   write_reg RIP w__0 >>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   write_reg RAX w__1 >>
   (undefined_bitvector (64)) >>= fun (w__2 : mword 64) =>
   write_reg RCX w__2 >>
   (undefined_bitvector (64)) >>= fun (w__3 : mword 64) =>
   write_reg RDX w__3 >>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   write_reg RBX w__4 >>
   (undefined_bitvector (64)) >>= fun (w__5 : mword 64) =>
   write_reg RSP w__5 >>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   write_reg RBP w__6 >>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   write_reg RSI w__7 >>
   (undefined_bitvector (64)) >>= fun (w__8 : mword 64) =>
   write_reg RDI w__8 >>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   write_reg R8 w__9 >>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   write_reg R9 w__10 >>
   (undefined_bitvector (64)) >>= fun (w__11 : mword 64) =>
   write_reg R10 w__11 >>
   (undefined_bitvector (64)) >>= fun (w__12 : mword 64) =>
   write_reg R11 w__12 >>
   (undefined_bitvector (64)) >>= fun (w__13 : mword 64) =>
   write_reg R12 w__13 >>
   (undefined_bitvector (64)) >>= fun (w__14 : mword 64) =>
   write_reg R13 w__14 >>
   (undefined_bitvector (64)) >>= fun (w__15 : mword 64) =>
   write_reg R14 w__15 >>
   (undefined_bitvector (64)) >>= fun (w__16 : mword 64) =>
   write_reg R15 w__16 >>
   (undefined_rflags (tt)) >>= fun (w__17 : mword 64) => write_reg RFLAGS w__17  : M (unit).

Definition sail_model_init (_ : unit) : M (unit) := (initialize_registers (tt))  : M (unit).



